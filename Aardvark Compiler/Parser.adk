from Data include OrderOfOps, Parenthesis
include Token, Lexer from Lexer
include ErrorHandler, ADK_Error from Errors

macro CHECK(x) {
    (return x) if type_of(x) == ADK_Error else x
}
static class Parser as this {
    let String code
    let [...String] code_lines
    let [...Token] tokens
    let Number pos = 0
    let [ErrorHandler, null] error_handler 
    let store_errors = true # If false, errors will be thrown immediately.
    let error_stack = [] 
    let awaiting_match = [] # If an error occurs on a line with an opening (, [, or {, it will be stored here to prevent errors with unmatched parentheses.
    $constructor(code, tokens, error_handler?, store_errors = true) {
        this.code = code # The code used by the lexer.
        this.code_lines = this.code.split("\n")
        this.tokens = tokens # The tokens emitted by the lexer.
        this.error_handler = error_handler
        this.store_errors = store_errors
    }

    #* Utility *#
    # Gets the token `n` after the current token.
    function peek(n=0)
        return this.tokens.(this.pos + n) if (this.pos + n < this.tokens.length) else null
    
    # Compare the next token with type, value
    function compare(token_type="any", value?, n=0) {
        if this.is_EOF() return false
        let current_token = this.peek(n)
        if current_token & (token_type == "any" | current_token.type == token_type) & (value == null | value == current_token.value)
            return true
        else return false
    }

    # Advance to the next token.
    function advance(n=1) this.pos += n

    # Helper function for error throwing.
    function Throw(type, message, options={}, note="", kill=true, position?, here_message="Here", show=true) {
        let legacy_errors = false
        if legacy_errors {
            if !(options.underline? | options.marker?) {
                options.underline = {
                    start: position.start.column + 1,
                    end: position.end.column + 1
                }
                options.marker = {
                    start: position.start.column + 1,
                    length: 1 + position.end.column - position.start.column
                }
            }
            options.line_number ?= options.lineno?(options.linestart?position.start.line)
            this.error_handler.Throw(type, message, options, note, kill)
        }
        let error = ADK_Error(this.error_handler, {
            error_type: type,
            message,
            location: {
                line: position.start.line - 1, # The error formatter starts line counting at 0.
                column: position.start.column - 1, # The error formatter starts column counting at 0.
            },
            markers: options.markers?[{
                line: position.start.line - 1, # The error formatter starts line counting at 0.
                column: position.start.column - 1, # The error formatter starts column counting at 0.
                length: (position.end.column - position.start.column + 1) if (position.end.line == position.start.line) else (this.code_lines.(position.start.line - 1).length - position.start.column + 2),
                message: here_message
            }],
            show,
            ...options
        })
        if this.store_errors {
            error_stack.add(error)
        } else {
            error.Throw(kill)
        }
        return error
    }

    # Eat all consecutive line breaks
    function eat_line_breaks() while this.compare('LineBreak') this.advance()

    # Is at the end of the file
    function is_EOF() this.pos >= this.tokens.length

    # Throw EOF error
    function throw_EOF_error(expected_token_type="any", expected_token_value?) {
        let current_line = this.code_lines.(-1)
        # Show the expected token if there is one.
        let suggestion
        if expected_token_value
            suggestion = $'"{expected_token_value}"'
        else 
            suggestion = expected_token_type

        let error = this.error_handler.create({
            error_type: "UnexpectedEndOfFile",
            message: "We didn't expect the file to end so soon!",
            location: {
                line: this.code_lines.length - 1,
                column: current_line.length - 1
            },
            markers: [{
                line: this.code_lines.length - 1,
                column: current_line.length,
                length: expected_token_value.length?1,
                message: $"Expected {suggestion}"
            }],
            error_number: 2
        }, true)
        this.error_stack.add(error)
        if !this.store_errors {
            error.Throw(kill)
        }
        return error
    }

    # Consume the current token if type and value match, else throw an error
    function eat(token_type="any", value?, keep_track=false) {
        # If it matches, eat and return it.
        let current_token = this.peek()
        if this.compare(token_type, value) {
            if current_token.value in ["(", "[", "{"] & keep_track {
                this.awaiting_match.add(current_token)
            }
            if current_token.value in [")", "]", "}"] & this.awaiting_match.length > 0 & Parenthesis.(this.awaiting_match.(-1).value) == current_token.value & keep_track {
                this.awaiting_match = this.awaiting_match.slice(0, -1)
            }
            this.advance()
            return current_token
        }
        
        # If we're at the end of the file, throw an error.
        if this.is_EOF()
            return this.throw_EOF_error(token_type, value);
        let show_error = true
        if current_token.value in [")", "]", "}"] & this.awaiting_match.length > 0 & Parenthesis.(this.awaiting_match.(-1).value) == current_token.value & this.error_stack.length > 0 {
            this.awaiting_match = this.awaiting_match.slice(0, -1)
            show_error = false
        }
        # Otherwise, throw an error because it didn't match.
        let x = (($'"{value}"') if value else $'of type {token_type}')
        return this.Throw(
            "Token",
            $"Token {($'\"{value}\"')if value else $'of type {token_type}'} expected, but not found.",
            position = this.peek().position,
            show = show_error
        )
    }
    function maybe_eat(token_type="any", value?)
        this.eat() if this.compare(token_type, value) else null
    
    # Parse values.
    function parse_primary(Boolean require=false, exclude=[], is_deconstruction=false, eat_line_breaks=false, is_structural_pattern=false) {
        let current_token = this.peek()
        let ast_node

        if !current_token | this.is_EOF()
            return this.throw_EOF_error('something to be here') if require else null;
        
        if this.compare("String")
           ast_node = this.parse_string()
        
        else if this.maybe_eat("Number") {
            let multiplied_by = this.parse_primary(require=false, exclude=["Keyword", "Object", "Array"])
            ast_node = {
                type: "NumberLiteral",
                value: current_token.value,
                base: current_token.variation,
                position: current_token.position,
            }
            if (multiplied_by?)
                ast_node = {
                    type: "Multiply",
                    left: ast_node,
                    right: multiplied_by,
                    position: {
                        start: ast_node.position.start,
                        end: multiplied_by.position.end
                    }
                }
        }
        else if this.maybe_eat("Boolean")
            ast_node = {
                type: "BooleanLiteral",
                value: current_token.value == "true",
                position: current_token.position
            }
        else if is_structural_pattern & this.maybe_eat("Delimiter", "$") {
            let value = "";
            if this.compare("Identifier")
                value = this.eat().value
            return {
                type: "ValueRetrieval",
                value: value,
                position: {
                    start: current_token.position.start,
                    end: this.peek(-1).position.end
                }
            }
        } else if this.compare('Delimiter', '{') & !exclude.contains('Object')
            ast_node = CHECK(this.parse_object(is_structural_pattern=is_structural_pattern))
        else if this.compare('Delimiter', '[') & !exclude.contains('Array')
            ast_node = CHECK(this.parse_array(is_deconstruction, is_structural_pattern=is_structural_pattern))
        
        # Variables
        else if !exclude.contains('VariableAccess') & this.maybe_eat("Identifier")
            ast_node = {
                type: 'VariableAccess',
                name: current_token.value,
                position: current_token.position
            }
        # Statements surrounded by ()
        else if this.maybe_eat('Delimiter', '(') {
            this.eat_line_breaks()
            ast_node = CHECK(this.parse_statement(eat_line_breaks=true))
            this.eat_line_breaks()
            this.eat('Delimiter', ')')
        }
        # Statements that return a value?????
        else if this.compare('Keyword') & !exclude.contains('Keyword')
        match this.peek().value {
            case 'static' {
                let next_token = this.peek(1)
                if next_token.compare('Keyword', 'private')
                    next_token = this.peek(2)
                if next_token.compare('Keyword', 'function')
                    ast_node = CHECK(this.parse_function_definition())
                else if next_token.compare('Keyword', 'class')
                    ast_node = CHECK(this.parse_class_definition())
                else
                    return this.Throw('SyntaxError', 'Expected "function" or "class" after "static"', position=next_token.position)
            }
            case 'private' {
                let next_token = this.peek(1)
                if next_token.compare('Keyword', 'static')
                    next_token = this.peek(2)
                if next_token.compare('Keyword', 'function')
                    ast_node = CHECK(this.parse_function_definition())
                else if next_token.compare('Keyword', 'class')
                    ast_node = CHECK(this.parse_class_definition())
                else
                    return this.Throw('SyntaxError', 'Expected "function" or "class" after "private"', position=next_token.position)
            }
            case 'function'
                ast_node = CHECK(this.parse_function_definition())
            case 'class'
                ast_node = CHECK(this.parse_class_definition())
            case 'if'
                ast_node = CHECK(this.parse_if_statement())
            case 'while'
                ast_node = CHECK(this.parse_while_loop())
            case 'for'
                ast_node = CHECK(this.parse_for_loop())
            case 'match'
                ast_node = CHECK(this.parse_match_statement())
            case 'await'
                ast_node = CHECK(this.parse_await_statement())
            case 'let'
                ast_node = CHECK(this.parse_assignment())
            case 'layout'
                ast_node = CHECK(this.parse_layout_type())
            case 'embed'
                ast_node = CHECK(this.parse_embed())
            case 'macro'
                ast_node = CHECK(this.parse_function_definition("normal", false, "macro"))
        }
        # If there were lines after the statement, just return
        if !(this.peek(-1).type == "LineBreak" & !eat_line_breaks)
        while ast_node?false {
            if eat_line_breaks
                this.eat_line_breaks()
            # Function calls
            if this.compare("Delimiter", '(') & this.peek().position.start.column == ast_node.position.end.column + 1 & !exclude.contains('FunctionCall') {
                ast_node = CHECK(this.parse_function_call(ast_node))
                continue
            }
            # Property access
            if this.compare('Delimiter', '.') {
                ast_node = CHECK(this.parse_property_access(ast_node))
                continue
            }

            # Tell the user that x[] should be x.()
            if this.compare('Delimiter', '[') & this.peek().position.start.column == ast_node.position.end.column + 1 {
                let opening_bracket = this.eat()
                let inner_node = CHECK(this.parse_expression(eat_line_breaks=true))
                let closing_bracket = CHECK(this.eat('Delimiter', ']'))
                let length
                if opening_bracket.position.start.line == closing_bracket.position.start.line
                    length = closing_bracket.position.end.column - opening_bracket.position.end.column + 1
                else # End of the line
                    length = this.code_lines.(opening_bracket.position.start.line - 1).length - opening_bracket.position.end.column + 1

                return this.Throw("SyntaxError", "Incorrect property access", {
                    markers: [
                        {
                            line: opening_bracket.position.start.line - 1,
                            column: opening_bracket.position.start.column - 1,
                            length,
                            message: "Use `x.(y)` syntax instead of `x[y]`"
                        }
                    ]
                }, position=opening_bracket.position)
            }
            # Re-assignment
            if this.compare("Operator", '=') & !exclude.contains('Reassignment') {
                ast_node = CHECK(this.parse_reassignment(ast_node))
                continue
            }
            # inline statements. Don't continue because nothing can come after it.
            if this.compare('Keyword') {
                match this.peek().value {
                    case 'if'
                        ast_node = CHECK(this.parse_if_statement(ast_node))
                    case 'while'
                        ast_node = CHECK(this.parse_while_loop(ast_node))
                    case 'for'
                        ast_node = CHECK(this.parse_for_loop(ast_node))
                    # case $default {
                    #     this.Throw('SyntaxError', 'Unexpected inline keyword "' + this.peek().value + '"', position=this.peek().position, here_message="What is this supposed to mean?")
                    # }
                }
            }
            # Return if none were found
            return ast_node
        }
        if ast_node?
            return ast_node
        if require {
            let show_error = true
            if current_token.value in [")", "]", "}"] & this.awaiting_match.length > 0 & Parenthesis.(this.awaiting_match.(-1).value) == current_token.value & this.error_stack.length > 0 {
                this.awaiting_match = this.awaiting_match.slice(0, -1)
                show_error = false
            }
            return this.Throw('SyntaxError', 'A value is supposed to go here', position=this.peek().position, show=show_error)
        }
    }
    # Parse an expression
    function parse_expression(level=keys(OrderOfOps).length-1, require=false, exclude=[], eat_line_breaks=false, is_deconstruction=false, is_structural_pattern=false) {
        let left = CHECK(this.parse_primary(false, exclude, is_deconstruction, eat_line_breaks, is_structural_pattern) if level < 0 else this.parse_expression(level - 1, false, exclude, eat_line_breaks, is_deconstruction, is_structural_pattern))
        this.eat_line_breaks() if eat_line_breaks;
        let excluded = exclude
        if !excluded.contains("=") excluded += ['=', '->'];
        # while the next token is an operator and level in OrderOfOps, and the value of the next token is in the current precedence level and the value of the next token is not in the exclude list.
        while this.compare('Operator') & level in OrderOfOps & this.peek().value in OrderOfOps.(level) & !(this.peek().value in excluded) {
            let operator = this.eat()
            if operator.value == "$="
                is_structural_pattern = true
            this.eat_line_breaks() if eat_line_breaks;
            let right = CHECK(this.parse_expression(level - 1, false, excluded, eat_line_breaks, is_deconstruction, is_structural_pattern))
            if !left & !right
                return this.Throw('SyntaxError', "Operators are invalid when lonely.", here_message="🤨 That's just an operator with nothing for it to operator on.", position=operator.position)
            left = {
                type: 'Operator',
                left: left,
                right: right,
                operator: operator.value,
                position: {
                    start: left.position.start if left else operator.position.start,
                    end: right.position.end if right else operator.position.end
                }
            }
        }
        if !left & require
            left = (CHECK(this.parse_primary(require, excluded, is_deconstruction, eat_line_breaks, is_structural_pattern))) if level < 0 else (CHECK(this.parse_expression(level - 1, require, excluded, eat_line_breaks, is_deconstruction, is_structural_pattern)));
        return left
    }
    # Parse a statement
    function parse_statement(require=false, is_deconstruction=false, mode="normal", mode_entry?) {

        this.eat_line_breaks()
        if mode == "class_scope" {
            if this.compare('Delimiter', "$")
                return this.parse_function_definition("class_scope")
            else if this.compare("Keyword", "function")
                return this.parse_function_definition("class_scope")
            else if this.compare("Keyword", "class")
                return this.parse_class_definition()
            else if this.compare("Keyword", "let")
                return this.parse_assignment()
            else
                return this.Throw("SyntaxError", "I mean, did you want me to execute this on class creation or something? It's pointless either way.", {
                    markers: [
                        {
                            line: mode_entry.position.start.line - 1,
                            column: mode_entry.position.start.column - 1,
                            length: mode_entry.position.end.column - mode_entry.position.start.column + 1,
                            message: "The troublesome class begins here"
                        },
                        {
                            line: this.peek().position.start.line - 1,
                            column: this.peek().position.start.column - 1,
                            length: this.peek().position.end.column - this.peek().position.start.column + 1,
                            message: "This is not valid in the class' scope"
                        }
                    ]
                }, position=this.peek().position)
        } else if mode == "match_scope" {
            if this.compare("Keyword", "case")
                return this.parse_case_statement()
            else
                return this.Throw("SyntaxError", "Not valid in match scope", position=this.peek().position)
        }
        if this.compare('Keyword') match this.peek().value {
            case 'return'
                return this.parse_return_statement()
            case 'break'
                return this.parse_break_statement()
            case 'continue'
                return this.parse_continue_statement()
            case 'defer'
                return this.parse_defer_statement()
            case 'yield'
                return this.parse_yield_statement()
            case 'include'
                return this.parse_include_statement()
            case 'from'
                return this.parse_include_statement()
            case 'extending'
                return this.parse_extending_statement()
        }
        return this.parse_expression(require=require, is_deconstruction=false)
    }
    # Parse a program
    function parse_program() {
        return CHECK(this.parse_scope_body(false))
    }
    function parse this.parse_program()

    #* Basic Values *#
    function parse_string() {
        let current_token = this.eat("String")
        let value = current_token.value
        let insertions = []
        for insertion in current_token.insertions {
            let new_parser = Parser(insertion.expression_text, insertion.tokens, this.error_handler)
            let insertion_ast_node = new_parser.parse_expression()
            this.error_stack += new_parser.error_stack
            insertions.add({
                position: insertion.position,
                ast_node: insertion_ast_node
            })
        }
        return {
            type: 'StringLiteral',
            value: value,
            insertions,
            position: current_token.position,
            quote_style: current_token.variation
        }
    }

    function parse_object(is_structural_pattern=false) {
        let opening_curly_brace = CHECK(this.eat("Delimiter", "{"))
        let pairs = []
        let expansions = []
        let ate_comma = false
        this.eat_line_breaks()
        # While there is no }
        while (this.peek() & !this.compare("Delimiter", "}")) {
            if pairs.length > 0 & !ate_comma {
                let comma = this.eat("Delimiter", ",")
                if type_of(comma) == ADK_Error {
                    comma.error_number = 1
                    return comma
                }
                this.eat_line_breaks()
            }
            ate_comma = false
            # Expansion with ...
            if this.maybe_eat("Operator", "...")
                expansions.add(CHECK(this.parse_expression(require=false, eat_line_breaks=true, is_structural_pattern=is_structural_pattern)))
            else if this.maybe_eat("Delimiter", "$")
                pairs.add({
                    type: "ValueRetrieval",
                    value: CHECK(this.eat("Identifier")),
                    position: {
                        start: this.peek(-2).position.start,
                        end: this.peek().position.end
                    }
                })
            else {
                let key = parse_typed_variable(["NumberLiteral", "StringLiteral", "TemplateString"], "object key")
                if type_of(key) == ADK_Error {
                    key.error_number = 1
                    return key
                }
                this.eat_line_breaks()
                let value
                # There is a :, then the value is on the other side
                if this.maybe_eat("Delimiter", ":") {
                    this.eat_line_breaks()
                    value = CHECK(this.parse_expression(require=true, eat_line_breaks=true, is_structural_pattern=is_structural_pattern))
                } else # Otherwise, the value is a variable access to the key value
                    value = key.variable
                pairs.add({
                    type: "KeyValuePair",
                    key: key.variable,
                    given_type: key.given_type,
                    value,
                    position: {
                        start: key.position.start,
                        end: value.position.end
                    }
                })
            }
            this.eat_line_breaks()
            if this.maybe_eat("Delimiter", ",")
                ate_comma = true
            this.eat_line_breaks()
        }
        this.eat_line_breaks()
        let closing_curly_brace = CHECK(this.eat("Delimiter", "}"))
        return {
            type: "Object",
            pairs,
            expansions,
            position: {
                start: opening_curly_brace.position.start,
                end: closing_curly_brace.position.end
            }
        }
    }

    function parse_array(is_deconstruction=false, is_structural_pattern=false) {
        let opening_bracket = CHECK(this.eat("Delimiter", "["))
        let items = []
        let expansions = []
        let ate_comma = false
        this.eat_line_breaks()
        # While there is no ]
        while (this.peek() & !this.compare("Delimiter", "]") & !(this.compare("Delimiter", ",") & this.peek(1).value == "]")) {
            if items.length > 0 & !ate_comma  {
                CHECK(this.eat("Delimiter", ","))
                this.eat_line_breaks()
            }
            ate_comma = false
            if is_deconstruction
                items.add(CHECK(this.parse_typed_variable(["..."])))
            else {
                if this.maybe_eat("Operator", "...")
                    expansions.add(CHECK(this.parse_expression(require=false, eat_line_breaks=true, is_structural_pattern=is_structural_pattern)))
                else
                    items.add(CHECK(this.parse_typed_variable(["*"],  is_structural_pattern=is_structural_pattern, name="value", var_level=keys(OrderOfOps).length-1, is_deconstruction=false)))
            }
            this.eat_line_breaks()
            if this.maybe_eat("Delimiter", ",") {
                ate_comma = true
                this.eat_line_breaks()
            }
        }
        let closing_bracket = CHECK(this.eat("Delimiter", "]"))
        return {
            type: "Array",
            items,
            expansions,
            position: {
                start: opening_bracket.position.start,
                end: closing_bracket.position.end
            }
        }
    }

    function parse_property_access(ast_node) {
        let dot = this.eat()
        this.eat_line_breaks()
        let property
        if this.compare('Identifier') {
            let token = this.eat()
            property = {
                type: "StringLiteral",
                value: token.value,
                position: token.position
            }
        }
        else if this.compare('Number') {
            let token = this.eat()
            property = {
                type: "NumberLiteral",
                value: Number(token.value),
                position: token.position
            }
        }
        else if this.compare("String") {
            let token = this.eat()
            property = {
                type: "StringLiteral",
                value: token.value,
                position: token.position
            }
        }
        else if this.compare("Delimiter", "(") {
            let token = this.eat()
            property = CHECK(this.parse_statement(eat_line_breaks=true))
            if !(property) {
                return this.Throw("SyntaxError", "What kinda property is this? It's empty!", position=token.position)
            }
            this.eat('Delimiter', ")")
        } else {
            return this.Throw("SyntaxError", "Expected property name", position=this.peek().position)
        }
        if !(property?) {
            if this.peek()
                return this.Throw("SyntaxError", "What kinda property is this?", position=this.peek().position)
            else
                return this.throw_EOF_error()
        }
        return {
            type: "PropertyAccess",
            property: property,
            value: ast_node,
            position: {
                start: ast_node.position.start,
                end: property.position.end
            }
        }
    }

    function parse_embed() {
        this.eat("Keyword", "embed")
        # TODO
    }

    function parse_for_loop(ast_node?) {
        let for_keyword = CHECK(this.eat("Keyword", "for"))
        let variable = CHECK(this.parse_typed_variable(["KeyValuePair"]))
        let in_keyword = CHECK(this.eat("Operator", "in"))
        let iterable = CHECK(this.parse_expression(require=true))
        let body = ast_node?CHECK(this.parse_statement_or_scope_body())
        let else_body
        if this.compare("Keyword", "else") {
            let else_keyword = this.eat()
            else_body = CHECK(this.parse_statement_or_scope_body())
        }
        return {
            type: "ForStatement",
            iterable,
            variable,
            body,
            else_body: else_body?,
            position: {
                start: for_keyword.position.start,
                end: body.position.end
            }
        }
    }

    function parse_while_loop(ast_node?) {
        let while_keyword = CHECK(this.eat("Keyword", "while"))
        let condition = CHECK(this.parse_expression(require=true))
        let body = ast_node?CHECK(this.parse_statement_or_scope_body())
        let else_body
        if this.compare("Keyword", "else") {
            let else_keyword = this.eat()
            else_body = CHECK(this.parse_statement_or_scope_body())
        }
        return {
            type: "WhileStatement",
            condition,
            body,
            else_body: else_body?,
            position: {
                start: while_keyword.position.start,
                end: body.position.end
            }
        }
    }

    function parse_layout_type() {
        let layout_keyword = CHECK(this.eat("Keyword", `layout`))
        CHECK(this.eat("Delimiter", `(`))
        let type = CHECK(this.parse_expression(require=true))
        this.eat("Delimiter", `)`)
        this.eat_line_breaks()
        let layout_obj = CHECK(this.parse_object())
        return {
            type: "LayoutType",
            layout_type: type,
            "layout": layout_obj,
            position: {
                start: layout_keyword.position.start,
                end: layout_obj.position.end
            }
        }
    }
    function parse_await_statement() {
        let await_keyword = CHECK(this.eat("Keyword", "await"))
        let expression = CHECK(this.parse_expression(require=true))
        return {
            type: "AwaitStatement",
            expression,
            position: {
                start: await_keyword.position.start,
                end: expression.position.end
            }
        }
    }
    function is_valid_type(expression, accept=[], accept_operators=[]) {
        let valid_operators = Set(accept_operators + ["|", "x|", "or", "xor", "?"])
        if expression == null | accept.contains(expression.type)
            return true
        else if ["VariableAccess", "PropertyAccess", "LayoutType", "Array", "Object", "KeyValuePair", "TypedVariable"].contains(expression.type) | (expression.type == "Operator" & valid_operators.contains(expression.operator))
        match expression.type {
            case "VariableAccess"
                return true
            case "PropertyAccess"
                return true
            case "LayoutType"
                return true
            case "Array"
                return !expression.items.map(function (x) is_valid_type(x, [], ["...", ...accept_operators])).contains(false)
            case "KeyValuePair"
                return is_valid_type(expression.key)
            case "Object"
                return !expression.pairs.map(is_valid_type).contains(false)
            case "Operator"
                return is_valid_type(expression.left) & is_valid_type(expression.right)
            case "TypedVariable"
                return true
        }
        return false
    }

    function is_valid_variable_definition(expression, accept=[]) {
        let acceptable = Set(accept + ["?"])
        if expression == null | accept.contains(expression.type) | acceptable.contains("*")
            return true
        else if ["VariableAccess", "PropertyAccess", "Array", "Object", "KeyValuePair", "TypedVariable"].contains(expression.type) | (expression.type == "Operator" & acceptable.contains(expression.operator))
        match expression.type {
            case "VariableAccess"
                return true
            case "PropertyAccess"
                return true
            case "KeyValuePair"
                return is_valid_variable_definition(expression.value)
            case "Array"
                return !expression.items.map(function(x) is_valid_variable_definition(x, ["...", ...acceptable])).contains(false)
            case "Object"
                return !expression.pairs.map(function(x) is_valid_variable_definition(x, acceptable)).contains(false)
            case "Operator" {
                let is_left_valid = is_valid_variable_definition(expression.left, acceptable)
                let is_right_valid = is_valid_variable_definition(expression.right, acceptable)
                return is_left_valid & is_right_valid
            }
            case "TypedVariable"
                return true
        }
        return false
    }

    function parse_typed_variable(accept_var=[], name="variable", var_level=0, is_structural_pattern=false, is_deconstruction=true) {
        # This may be the type or the variable, we don't know until we know IF there is a second expression.
        let first = CHECK(this.parse_expression(var_level, true, ["Reassignment"], false, is_deconstruction=is_deconstruction, is_structural_pattern=is_structural_pattern))
        let second = CHECK(this.parse_expression(var_level, false, ["Reassignment"], false, is_deconstruction=is_deconstruction, is_structural_pattern=is_structural_pattern))
        if !first {
            return this.Throw("AssignmentError", $"There's nothing here...", position=this.peek().position, here_message= $"Expected a {name} or type.")
        }
        if second {
            if !is_valid_type(first)
                return this.Throw("SyntaxError", "Invalid syntax.", position=first.position, here_message= $"Expected type.", error_number=3)
            if !is_valid_variable_definition(second, accept_var)
                return this.Throw("SyntaxError", $"You can't assign a value to something; a value already has a value, because it is one.", position=second.position, here_message= $"Expected a {name}.", error_number=41)
        }
        else if !is_valid_variable_definition(first, accept_var)
            return this.Throw("SyntaxError", $"You can't assign a value to something; a value already has a value, because it is one.", position=first.position, here_message= $"Expected a {name}.", error_number=40)

        let ast_node = {
            type: "TypedVariable",
            given_type: first if second else null,
            variable: second?first,
            position: {
                start: first.position.start,
                end: second.position.end if second else first.position.end
            }
        }
        if accept_var.contains("KeyValuePair") & this.maybe_eat("Delimiter", ":") {
            let value = CHECK(this.parse_typed_variable(accept_var, name, var_level, is_structural_pattern=is_structural_pattern))
            return {
                type: "KeyValuePair",
                key: ast_node,
                value,
                position: {
                    start: ast_node.position.start,
                    end: value.position.end
                }
            }
        }

        return ast_node
    }

    function parse_assignment() {
        let let_keyword = CHECK(this.eat("Keyword", "let"))
        let is_embed_assignment = false
        if this.maybe_eat("Operator", "%")
            is_embed_assignment = true
        assignments = []
        while true {
            if assignments.length > 0
                CHECK(this.eat("Delimiter", ","))
            let is_static = false
            let is_private = false
            # Allow static and private in any order
            if this.maybe_eat("Keyword", "static")
                is_static = true
            if this.maybe_eat("Keyword", "private")
                is_private = true
            if this.maybe_eat("Keyword", "static")
                is_static = true
            let variables = []
            let value
            while true {
                let previous_store_errors_state = this.store_errors
                let previous_position = this.pos
                this.store_errors = true
                let x = this.parse_typed_variable(["KeyValuePair"])
                if (type_of(x) == ADK_Error & [3, 40].contains(x.error_number)) | (!this.compare("Operator", "=") & variables.length > 0) {
                    this.store_errors = previous_store_errors_state
                    this.error_stack = this.error_stack.slice(0, -1)
                    this.pos = previous_position
                    value = CHECK(this.parse_expression(require=true, exclude=["Reassignment"]))
                    break
                } else if type_of(x) == ADK_Error 
                    return x
                else
                    variables.add(x)
                if !(value?) & variables.length == 1 & !this.compare("Operator", "=")
                    break
                CHECK(this.eat("Operator", "="))
            }
            if !(value?) & variables.length > 1
                return this.Throw("AssignmentError", "No Value was given", position=variables.(-1).position)

            assignments.add({
                type: "Assignment",
                variables,
                value: value?,
                is_static: is_static,
                is_private: is_private,
                position: {
                    start: variables.0.position.start,
                    end: value.position.end if value? else variables.(-1).position.end
                }
            })
            if !this.compare("Delimiter", ",") break
        }
        return {
            type: "Assignments",
            assignments,
            is_embed_assignment,
            position: {
                start: let_keyword.position.start,
                end: assignments.(-1).position.end
            }
        }
    }

    function parse_function_definition(mode="normal", found_static=false, expected_keyword="function") {
        let is_static = found_static
        let is_private = false
        let parameters = []
        let first_keyword, label, name, return_type, body, parameter_expansion, function_keyword
        if this.compare("Keyword", "static") {
            first_keyword = this.eat()
            is_static = true
        }
        if this.compare("Keyword", "private") {
            let keyword = this.eat()
            if (!first_keyword?)
                first_keyword = keyword
            is_private = true
        }
        if this.compare("Keyword", "static") {
            let keyword = this.eat()
            if (!first_keyword?) 
                first_keyword = keyword
            is_static = true
        }
        # the function keyword is required unless we're in a class scope or extending 
        if !["extending", "class_scope"].contains(mode)
            function_keyword = CHECK(this.eat("Keyword", expected_keyword))
        else # Otherwise it's optional
            function_keyword = this.maybe_eat("Keyword", expected_keyword)
        
        if mode == "class_scope" & this.compare("Delimiter", "$") {
            function_keyword = this.eat()
            let token = CHECK(this.eat("Identifier"))
            name = {
                type: "VariableAccess",
                name: '$' + token.value,
                position: token.position
            }
        }

        if (!first_keyword? & function_keyword?)
            first_keyword = function_keyword

        if !(name?) & this.compare("Identifier") {
            let token = this.eat()
            name = {
                type: "VariableAccess",
                name: token.value,
                position: token.position
            }
        }

        if (!first_keyword? & name?)
            first_keyword = name

        if this.compare("Delimiter", "(") {
            let opening_parenthesis = this.eat()
            if (!first_keyword?)
                first_keyword = opening_parenthesis
            let ate_comma = false
            this.eat_line_breaks()
            while !this.compare("Delimiter", ")") {
                if parameters.length > 0 & !ate_comma {
                    CHECK(this.eat("Delimiter", ","))
                    ate_comma = false
                    this.eat_line_breaks()
                }
                if this.compare("Operator", "...") {
                    let operator = this.eat()
                    parameter_expansion = CHECK(this.parse_primary(true))
                    if !["VariableAccess", "PropertyAccess"].contains(parameter_expansion.type) 
                        return this.Throw("SyntaxError", "Invalid syntax.", position=parameter_expansion.position, here_message= $"Expected parameter name.")
                    # An expansion MUST be the last parameter
                    break
                }
                let parameter = CHECK(this.parse_typed_variable())
                let default
                if this.compare("Operator", "=") {
                    let operator = this.eat()
                    default = CHECK(this.parse_expression(require=true))
                }
                parameter.default = default?
                parameters.add(parameter)
                this.eat_line_breaks()
                if this.maybe_eat("Delimiter", ",") {
                    ate_comma = true
                    this.eat_line_breaks()
                }
            }
            let closing_parenthesis = this.eat("Delimiter", ")")
        }
        # Parse labels
        if this.maybe_eat("Keyword", "as")
            label = CHECK(this.eat("Identifier"))

        # Parse return type
        if this.compare("Operator", "->") {
            let operator = this.eat()
            if (!first_keyword?)
                first_keyword = operator
            return_type = CHECK(this.parse_primary(require=true))
            if !this.is_valid_type(return_type) {
                return this.Throw("SyntaxError", "Invalid syntax.", position=return_type.position, here_message= $"Expected a type.")
            }
        }
        body = CHECK(this.parse_statement_or_scope_body())
        return {
            type: "FunctionDefinition" if expected_keyword == "function" else if expected_keyword == "macro" "MacroDefinition",
            name: name?,
            parameters,
            parameter_expansion: parameter_expansion?,
            return_type: return_type?,
            body,
            label: label?,
            is_static,
            is_private,
            position: {
                start: first_keyword.position.start if first_keyword? else body.position.start,
                end: body.position.end
            }

        }
    }

    function parse_statement_or_scope_body(mode="normal") {
        let body
        this.eat_line_breaks()
        if this.compare("Delimiter", "{") {
            if this.compare("Delimiter", "}", 1)
                return {
                    type: "ScopeBody",
                    statements: [],
                    position: {
                        start: this.eat().position.start,
                        end: this.eat().position.end
                    }
                }
            let previous_store_errors_state = this.store_errors
            this.store_errors = true
            let previous_position = this.pos
            body = this.parse_object()
            this.store_errors = previous_store_errors_state
            if type_of(body) == ADK_Error & body.error_number == 1 {
                this.pos = previous_position
                this.error_stack = this.error_stack.slice(0, -1)
                body = CHECK(this.parse_scope_body(true, mode))
            }
        } else
            body = CHECK(this.parse_statement(require=true, mode=mode))
        return body
    }

    function parse_if_statement(ast_node) {
        # ast_node is provided if the body comes before the if keyword. That is, it is an inline if statement.
        let if_keyword = CHECK(this.eat("Keyword", "if"))
        let condition = CHECK(this.parse_expression(require=true))
        let body, else_body
        if ast_node
            body = ast_node
        else
            body = CHECK(this.parse_statement_or_scope_body())
        this.eat_line_breaks()
        # Handle else statements
        if this.compare("Keyword", "else") {
            let else_keyword = this.eat()
            else_body = CHECK(this.parse_statement_or_scope_body())
        }
        return {
            type: "IfStatement",
            condition,
            body,
            else_body: else_body?,
            position: {
                start: if_keyword.position.start,
                end: else_body.position.end if else_body? else body.position.end
            }
        }
    }

    function parse_class_definition() {
        let name, label
        let is_static = false
        let is_private = false
        if this.maybe_eat("Keyword", "static")
            is_static = true
        if this.maybe_eat("Keyword", "private")
            is_private = true
        if this.maybe_eat("Keyword", "static")
            is_static = true
        let class_keyword = CHECK(this.eat("Keyword", "class"))
        if this.compare("Identifier") {
            let token = this.eat()
            name = {
                type: "VariableAccess",
                name: token.value,
                position: token.position
            }
        }
        if this.maybe_eat("Keyword", "as") 
            label = CHECK(this.eat("Identifier"))
        let body = CHECK(this.parse_scope_body(true, "class_scope", class_keyword))
        return {
            type: "ClassDefinition",
            name: name?,
            body,
            label: label?,
            is_static,
            is_private,
            position: {
                start: class_keyword.position.start,
                end: body.position.end
            }
        }
    }

    function parse_return_statement() {
        let return_keyword = CHECK(this.eat("Keyword", "return"))
        let value = CHECK(this.parse_expression(require=true))
        return {
            type: "ReturnStatement",
            value,
            position: {
                start: return_keyword.position.start,
                end: value.position.end
            }
        }
    }

    function parse_continue_statement() {
        let continue_keyword = CHECK(this.eat("Keyword", "continue"))
        return {
            type: "ContinueStatement",
            position: {
                start: continue_keyword.position.start,
                end: continue_keyword.position.end
            }
        }
    }

    function parse_break_statement() {
        let break_keyword = CHECK(this.eat("Keyword", "break"))
        return {
            type: "BreakStatement",
            position: {
                start: break_keyword.position.start,
                end: break_keyword.position.end
            }
        }
    }

    function parse_yield_statement() {
        let yield_keyword = CHECK(this.eat("Keyword", "yield"))
        let value = CHECK(this.parse_expression(require=true))
        return {
            type: "YieldStatement",
            value,
            position: {
                start: yield_keyword.position.start,
                end: value.position.end
            }
        }
    }

    function parse_defer_statement() {
        let defer_keyword = CHECK(this.eat("Keyword", "defer"))
        let body = CHECK(this.parse_statement_or_scope_body())
        return {
            type: "DeferStatement",
            body,
            position: {
                start: defer_keyword.position.start,
                end: body.position.end
            }
        }
    }
    function parse_include_statement() {
        let starting_keyword
        let global_origin
        if this.compare("Keyword", "from") {
            starting_keyword = this.eat()
            global_origin = CHECK(this.parse_primary(require=true, exclude=["as"]))
            if !is_valid_variable_definition(global_origin)
                return this.Throw("SyntaxError", "Expected 'Identifier' or 'String'.", position=global_origin.position, here_message="That is not a library name, at least not one that the compiler can recognize.")
        }
        if this.compare("Keyword", "include") {
            starting_keyword = this.eat()
            let included_things = []
            while !(this.compare("Delimiter", "from") | this.compare("LineBreak")) & this.peek() {
                let thing, name, origin
                if included_things.length > 0
                    CHECK(this.eat("Delimiter", ","))
                if this.compare("Operator", "...")
                    thing = {
                        type: "AllExpansion",
                        position: this.eat().position
                    }
                else {
                    thing = CHECK(this.parse_primary(require=true, exclude=["as"], is_deconstruction=true))
                    if !is_valid_variable_definition(thing)
                        return this.Throw("SyntaxError", "Expected 'Identifier' or 'String'.", position=thing.position, here_message="That is not a library name, at least not one that the compiler can recognize.")
                }
                if this.maybe_eat("Keyword", "as")
                    name = CHECK(this.eat("Identifier"))
                if this.maybe_eat("Keyword", "from") {
                    if (global_origin?) {
                        let cause = this.peek(1)?this.peek()
                        return this.Throw("SyntaxError", "I literally shouldn't even have to tell you what's wrong here.", {
                            markers: [
                            {
                                line: global_origin.position.start.line - 1,
                                column: global_origin.position.start.column - 1,
                                length: global_origin.position.end.column - global_origin.position.start.column + 1,
                                message: "You told us to include that stuff from this library."
                            },
                            {
                                line: cause.position.start.line - 1,
                                column: cause.position.start.column - 1,
                                length: cause.position.end.column - cause.position.start.column + 1,
                                message: "So what is this supposed to mean? I'm a compiler you know, I can't just read your thoughts."
                            }
                        ]
                        }, position=this.peek().position)
                    }
                    origin = CHECK(this.parse_primary(require=true, exclude=["as"]))
                    if !is_valid_variable_definition(origin)
                        return this.Throw("SyntaxError", "Expected 'Identifier' or 'String'.", position=origin.position, here_message="That is not a library name, at least not one that the compiler can recognize.")
                }
                included_things.add({
                    type: "IncludedThing",
                    thing: thing?,
                    name: name?,
                    origin: (origin?(global_origin?)).value?null,
                }) # TODO: add position?
            }
            return {
                type: "IncludeStatement",
                included_things,
                position: {
                    start: starting_keyword.position.start,
                    end: this.peek(-1).position.end
                }
            }
        } else
            return this.Throw("SyntaxError", "Expected 'include' or 'from'.", position=this.peek().position)
    }

    function parse_extending_statement() {
        let extending_keyword = CHECK(this.eat("Keyword", "extending"))
        let object, extension
        let is_static = false
        if this.compare("Keyword", "static") & this.compare("Keyword", "function", 1) | this.compare("Keyword", "function")
            extension = CHECK(this.parse_function_definition())
        else if this.compare("Keyword", "static") & this.compare("Keyword", "class", 1) | this.compare("Keyword", "class")
            extension = CHECK(this.parse_class_definition())
        if (extension?) {
            if (!extension.name?)
                return this.Throw("ExtensionError", "It's completely pointless to extend it if it is anonymous! You literally can't do anything with it!", position=extension.position, here_message="Anonymous")
            return {
                type: "ExtendingStatement",
                object: extension.name,
                extension,
                position: {
                    start: extending_keyword.position.start,
                    end: extension.position.end
                }
            }
        }
        if this.maybe_eat("Keyword", "static")
            is_static = true
        if this.compare("Identifier") {
            # Handles x, x.y, x.(y)
            let identifier = this.eat()
            object = {
                type: "VariableAccess",
                name: identifier.value,
                position: identifier.position
            }
            if this.compare('Delimiter', '.') & this.peek().position.start.column == ast_node.position.end.column + 1 {
                object = CHECK(this.parse_property_access(object))
            }
        } else if this.compare("Operator") {
            let operator = this.eat()
            object = {
                type: "OperatorValue",
                value: operator.value,
                position: operator.position
            }
        }
        if this.compare("Operator", "->") {
            let operator = this.eat()
            let type = CHECK(this.parse_primary(require=true))
            if !this.is_valid_type(type) {
                return this.Throw("SyntaxError", "Invalid syntax.", position=type.position, here_message= $"Expected type.")
            }
            let body = CHECK(this.parse_statement_or_scope_body())
            extension = {
                type: "FunctionDefinition",
                name: object,
                type: type,
                parameters: [],
                parameter_expansion: null,
                is_static: is_static,
                is_private: null,
                body: body,
                position: {
                    start: object.position.start,
                    end: body.position.end
                }
            }
        } else if this.compare("Delimiter", "(")
            extension = CHECK(this.parse_function_definition("extending", is_static))
        else if this.compare("Delimiter", "[")
            extension = CHECK(this.parse_array())
        else
            extension = CHECK(this.parse_statement_or_scope_body())


        return {
            type: "ExtendingStatement",
            object,
            extension,
            position: {
                start: extending_keyword.position.start,
                end: extension.position.end
            }
        }
    }

    function parse_function_call(ast_node) {
        let opening_parenthesis = CHECK(this.eat("Delimiter", "("))
        let arguments = []
        let keyword_arguments = []
        let ate_comma = false
        this.eat_line_breaks()
        while !this.compare("Delimiter", ")") {
            if (arguments.length > 0 | keyword_arguments.length > 0) & !ate_comma {
                CHECK(this.eat("Delimiter", ","))
                this.eat_line_breaks()
            }
            ate_comma = false
            let value = CHECK(this.parse_expression(exclude=['Reassignment']))
            if this.maybe_eat("Operator", "=") {
                let key = value
                if !this.is_valid_variable_definition(key)
                    return this.Throw("SyntaxError", $"Invalid syntax.", position=first.position, here_message= $"Expected parameter name.")
                let value = CHECK(this.parse_expression())
                keyword_arguments.add({
                    type: "KeyValuePair",
                    key: key,
                    value,
                    position: {
                        start: key.position.start,
                        end: value.position.end
                    }
                })
            } else 
                arguments.add(value)
            this.eat_line_breaks()
            if this.maybe_eat("Delimiter", ",") {
                ate_comma = true
                this.eat_line_breaks()
            }
        }
        if this.compare("Delimiter", ",") this.eat()
        let closing_parenthesis = this.eat("Delimiter", ")")
        return {
            type: "FunctionCall",
            object: ast_node,
            arguments,
            keyword_arguments,
            position: {
                start: opening_parenthesis.position.start,
                end: closing_parenthesis.position.end
            }
        }
    }

    function parse_reassignment(ast_node) {
        if !this.is_valid_variable_definition(ast_node) {
            return this.Throw("SyntaxError", $"Invalid syntax.", position=ast_node.position, here_message= $"Expected identifier (variable or property).")
        }
        let objects = [ast_node]
        let value
        # Reassignment chaining, x = y = z
        while true {
            CHECK(this.eat("Operator", "="))
            if (value?) {
                if !this.is_valid_variable_definition(ast_node) {
                    return this.Throw("SyntaxError", $"Invalid syntax.", position=ast_node.position, here_message= $"Expected identifier (variable or property).")
                }
                objects.add(value)
            }
            value = CHECK(this.parse_expression(require=true, exclude=["Reassignment"]))
            if !this.compare("Operator", "=") break
        }

        return {
            type: "Reassignment",
            objects,
            value,
            position: {
                start: ast_node.position.start,
                end: value.position.end
            }
        }
    }
    function parse_case_statement() {
        let case_keyword = CHECK(this.eat("Keyword", "case"))
        let expression = CHECK(this.parse_expression(require=true, is_structural_pattern=true))
        let body = CHECK(this.parse_statement_or_scope_body())
        return {
            type: "CaseStatement",
            value: expression,
            body,
            position: {
                start: case_keyword.position.start,
                end: body.position.end
            }
        }
    }
    function parse_match_statement() {
        let match_keyword = CHECK(this.eat("Keyword", "match"))
        let expression = CHECK(this.parse_expression())
        let body = CHECK(this.parse_scope_body(true, "match_scope"))
        return {
            type: "MatchStatement",
            expression,
            body,
            position: {
                start: match_keyword.position.start,
                end: body.position.end
            }
        }
    }

    function parse_scope_body(enclosing_curly_braces=true, mode="normal", entry_point="") {
        let beginning_token = this.peek()
        let opening_curly_brace, closing_curly_brace
        if enclosing_curly_braces 
            opening_curly_brace = CHECK(this.eat("Delimiter", "{"))
        let statements = []
        while !(enclosing_curly_braces & this.compare("Delimiter", "}")) & !this.is_EOF() {
            if statements.length > 0 & this.peek(-1).type != 'LineBreak' CHECK(this.eat('LineBreak'))
            this.eat_line_breaks()
            if this.is_EOF() | (enclosing_curly_braces & this.compare("Delimiter", "}")) break;
            let statement
            while !(statement? | this.is_EOF() | (this.compare("Delimiter", "}") & enclosing_curly_braces)) {
                statement = this.parse_statement(true, false, mode, entry_point)
                if type_of(statement) == ADK_Error {
                    while !this.is_EOF() {
                        this.eat(keep_track=true)
                        if this.compare("LineBreak") | this.is_EOF() break
                    }
                    this.eat_line_breaks()
                    statement = null;
                }
            }
            if !(statement?) break
            statements.add(statement)
            this.eat_line_breaks()
        }

        if enclosing_curly_braces 
            closing_curly_brace = CHECK(this.eat("Delimiter", "}"))

        let start_position, end_position
        if !enclosing_curly_braces & this.is_EOF() & statements.length == 0 {
            # There was nothing here at all
            start_position = null 
            # It has no start and no end, because it is nothing.
            end_position = null
        } else if !enclosing_curly_braces & this.is_EOF() & statements.length > 0 {
            # There was something, but it ended with an EOF
            start_position = statements.0.position.start
            end_position = this.peek(-1).position.end
        } else if !enclosing_curly_braces & statements.length == 0 {
            # There wasn't anything here, but there's more to the file.
            start_position = null 
            # It has no start and no end, because it is nothing.
            end_position = null
        } else if !enclosing_curly_braces & statements.length > 0 {
            # There was something here, but no curly braces to enclose it. There was no EOF.
            start_position = beginning_token ? statements.0.position.start
            end_position = this.peek(-1).position.end
        } else if enclosing_curly_braces {
            # It was enclosed, so the start is the opening curly brace and the end is the closing
            start_position = opening_curly_brace.position.start
            end_position = closing_curly_brace.position.end
        } 
        return {
            type: "ScopeBody",
            statements,
            enclosing_curly_braces,
            position: {
                start: start_position,
                end: end_position
            }
        }
    }
}