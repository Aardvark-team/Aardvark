from Data include OrderOfOps
include Token, Lexer from Lexer
include ErrorHandler from Errors


static class Parser as this {
    let String code
    let [...String] code_lines
    let [...Token] tokens
    let Number pos = 0
    let [ErrorHandler, null] error_handler
    let Lexer lexer
    $constructor(Lexer lexer, error_handler=null) {
        this.code = lexer.data # The code used by the lexer.
        this.code_lines = this.code.split("\n")
        this.tokens = lexer.output # The tokens emitted by the lexer.
        this.error_handler = error_handler
        this.lexer = lexer
    }
    #* Utility *#
    # Gets the token `n` after the current token.
    function peek(n=0)
        return this.tokens.(this.pos + n) if (self.pos + n < this.tokens.length) else null
    
    # Compare the next token with type, value
    function compare(token_type="any", value=null, n=0) {
        if this.is_EOF() return false
        let current_token = this.peek(n)
        if current_token & (token_type == "any" | current_token.type == token_type) & (value == null | value == current_token.value)
            return true
        else return false
    }

    # Advance to the next token.
    function advance(n=1) this.pos += n

    # Eat all consecutive linebreaks
    function eat_line_breaks() while this.compare('LineBreak') this.advance()

    # Is at the end of the file
    function is_EOF() this.pos >= this.tokens.length

    # Throw EOF error
    function throw_EOF_error(expected_token_type="any", expected_token_value=null) {
        let current_line = this.code_lines.(-1)
        
        # Show the expected token if there is one.
        let suggestion = expected_token_value?$"<{expected_token_type}>"

        self.error_handler.Throw(
            "EOF",
            "Unexpected EOF.",
            {
                line_number: this.code_lines.length - 1,
                did_you_mean: (current_line + suggestion) if expected_token_type != "any" else null
            }
        )
    }
    # Consume the current token if type and value match, else throw an error
    function eat(token_type="any", value=null) {
        # If it matches, eat and return it.
        if this.compare(token_type, value) {
            let current_token = this.peek()
            this.advance()
            return current_token
        }
        
        # If we're at the end of the file, throw an error.
        if this.is_EOF()
            return this.throw_EOF_error(token_type, value);

        # Otherwise, throw an error because it didn't match.
        self.error_handler.Throw(
            "Token",
            $"Token {value?$' of type {token_type}'} expected, but not found.",
            {
                line_number: this.peek().position.line
            }
        )
    }
    
    # Actually parse it
    function parse_primary(Boolean require=false) {
        let current_token = this.peek()
        let Object ast_node
        if !current_token | this.is_EOF()
            return this.EOFError('Value') if require else null;
        
        # Template Strings
        else if this.compare('Operator', '$') & this.peek(1).compare('String', null, 2) {
            let start = this.eat()
            let string = this.eat()

            let template_string = string.value
            let text = ""
            let index = 0
            let replacements = []
            while index < template_string.length {
                # Handles {{
                if template_string[index] == "{" & index + 1 < template_string.length & template_string[index + 1] == "{" {
                    index += 2
                    text += "{"
                }
                # If we hit a {
                else if template_string[index] == "{" {
                    index += 1
                    let starti = index
                    let inner = ""
                    let opener_count = 1
                    
                    # Loop until the string ends or the { is closed
                    while index < template_string.length & opener_count > 0 {
                        if template_string[index] == "{" opener_count++
                        else if template_string[index] == "}" opener_count--
                        inner += template_string[index]
                        index += 1
                    }

                    if opener_count > 0 {
                        # Throw error, replacement never closed
                        this.throw_EOF_error('Delimiter', '}')
                    }

                    if inner == "" {
                        # Throw error, empty replacement
                        this.throw_EOF_error('')
                    }
                    # Cut off the }
                    inner = inner.slice(0, -1)
                    # Tokenize the code inside {}
                    let inner_toks = this.lexer.tokenize(inner)
                    # Save current state
                    let saved_tokens = this.tokens
                    let saved_pos = this.pos
                    # Reset State to parse
                    this.tokens = inner_toks
                    this.pos = 0
                    # Parse
                    inner_ast = this.pExpression()
                    # Restore State
                    this.tokens = saved_tokens
                    this.pos = saved_pos

                    replacements.add({"from": starti, "to": index, "value": inner_ast, "string": inner})
                }
                else
                    text += template_string[index]

                index += 1
            }
            ast_node = {
                type: "TemplateString",
                position: {start: start.start, end: string.end},
                value: string.value,
                replacements: replacements
            }
        }
        else if current_token.type in ["String", "Number", "Boolean"] {
            this.eat()
            let value
            if current_token.type == "String"
                value = current_token.value
            else if current_token.type == "Boolean"
                value = current_token.value == "true"
            else
                value = Number(current_token.value)
            ast_node = {
                type: current_token.type + 'Literal',
                position: current_token.position,
                value: value
            }
        }
        else if this.compare('Delimiter', '{') 
            ast_node = this.parse_object()

        else if this.compare('Delimiter', '[') 
            ast_node = this.parse_array()
        
        # Variables
        else if tok.type == "Identifier" {
            this.eat()
            if current_token.value == "set" & this.compare("Delimiter", "{")
                ast_node = this.parse_set();
            else 
                ast_node = {
                    type: 'VariableAccess',
                    value: tok.value,
                    position: tok.position
                }
        }
        # Statements surrounded by ()
        else if this.compare('Delimiter', '(') {
            this.eat()
            this.eat_line_breaks()
            ast_node = this.parse_statement(eat_line_breaks=true)
            this.eat_line_breaks()
            this.eat('Delimiter', ')')
        }

        else if this.compare('Keyword', 'static') {
            let next_token = this.peek()
            if next_token.compare('Keyword', 'function')
                ast_node = this.parse_function_definition()
            else if next_token.compare('Keyword', 'class')
                ast_node = this.parse_class_definition()
            else
                this.error_handler.Throw('SyntaxError', 'Expected "function" or "class" after "static"')
        }
        else if this.compare('Keyword') match this.peek().value {
            case 'function'
                ast_node = this.parse_function_definition()
            case 'class'
                ast_node = this.parse_class_definition()
            case 'if'
                ast_node = this.parse_if_statement()
            case 'while'
                ast_node = this.parse_while_statement()
            case 'for'
                ast_node = this.parse_for_statement()
            case 'match'
                ast_node = this.parse_match_statement()
            case 'await'
                ast_node = this.parse_await_statement()
            case 'let'
                ast_node = this.parse_assignment()
        }

        while ast_node {
            # side-by-side multiply (i.e. 2x)
            if this.compare("Identifier") & this.peek().start.column == ast_node.position.end.column + 1 {
                let token = this.eat()
                ast_node = {
                    type: "Multiply",
                    value: ast_node,
                    variable: token.value,
                    position: {
                        start: ast_node.position.start,
                        end: token.end
                    }
                }
            }
            # Function calls
            if this.compare("Delimiter", '(') & this.peek().start.column == ast_node.position.end.column + 1 {
                ast_node = this.pFunctionCall(ast_node)
                continue
            }
            # Property access
            if this.compare('Delimiter', '.') {
                this.eat()
                let property_name = this.eat('Identifier')
                ast_node = {
                    type: "PropertyAccess",
                    property: property_name.value,
                    value: ast_node,
                    position: {
                        start: ast_node.position.start,
                        end: property_name.end
                    }
                }
                continue;
            }
            # inline statements. Don't continue because nothing can come after it.
            if this.compare('Keyword') match this.peek().value {
                case 'if'
                    ast_node = this.parse_if_statement(ast_node)
                case 'while'
                    ast_node = this.parse_while_statement(ast_node)
                case 'for'
                    ast_node = this.parse_for_statement(ast_node)
            }
            # Return if none were found
            return ast_node
        }
        if require {
            this.error_handler.Throw('SyntaxError', 'Expected statement')
        }
    }
    function parse_expresion(level=keys(OrderOfOps).length-1, require=false, exclude=[], eat_line_breaks=false) {
        let left = this.pPrimary(false) if level < 0 else this.pExpression(level - 1, false, exclude, eat_line_breaks)
        let right
        # if the next token is an operator, and the next token != '$' and level in OrderOfOps, and the value of the next token is in the current precedence level and the value of the next token is not in the exclude list.
        this.eat_line_breaks() if eat_line_breaks;
        if this.compare('Operator') & this.peek().value != '$' & level in OrderOfOps & this.peek().value in OrderOfOps[level] & !(this.peek().value in exclude) {
            let operator = this.eat()
            this.eat_line_breaks() if eat_line_breaks;
            right = this.pExpression(level, false, eat_line_breaks)
            if !left and !right {
                this.error_handler.Throw('SyntaxError', 'Expected expression')
                # Throw an error because its just an operator all by itself
            }
            return {
                type: 'Operator',
                left: left,
                right: right,
                operator: operator.value,
                position: {
                    start: left.position.start if left else op.start,
                    end: right.position.end if right else op.end
                }
            }
        }
        if !left & require
            left = (this.pPrimary(require)) if level < 0 else (this.pExpression(level - 1, require, exclude, eat_line_breaks));
        return left
    }
    function parse_statement(require=false) {
        this.eat_line_breaks()
        if this.compare('Keyword') match this.peek().value {
            case 'return'
                return this.parse_return_statement()
            case 'break'
                return this.parse_break_statement()
            case 'continue'
                return this.parse_continue_statement()
            case 'defer'
                return this.parse_defer_statement()
            case 'yield'
                return this.parse_yield_statement()
            case 'include'
                return this.parse_include_statement()
        }
        return this.parse_expresion(require=require)
    }
    function parse_program() {
        statements = []
        while !this.is_EOF() {
            if statements.length > 0 & this.peek(-1).type != 'LineBreak' this.eat('LineBreak')
            this.eat_line_breaks()
            if this.is_EOF() break;
            statements.add(this.parse_statement(true))
        }
        return {
            type: "Program",
            body: statements,
            position: {
                start: 0 if statements.length == 0 else statements[0].position.start,
                end: 0 if statements.length == 0 else statements[-1].position.end
            }
        }
    }
    function parse this.parse_program()
}
function test() {
    let code = "let x = 5"
    let error_handler = ErrorHandler(code, '<main>')
    let lexer = Lexer(false, false, error_handler)
    let tokens = lexer.tokenize(code)
    let parser = Parser(lexer, error_handler)
    let AST = parser.parse()
    stdout.write(AST, '\n')
}
test()