from Data include OrderOfOps, Parenthesis
include Token, Lexer from Lexer
include ErrorHandler, ADK_Error from Errors

macro CHECK(x) {
    (return x) if type_of(x) == ADK_Error else x
}
static class Parser as this {
    let String code
    let [...String] code_lines
    let [...Token] tokens
    let Number pos = 0
    let [ErrorHandler, null] error_handler
    let store_errors = true
    let error_stack = []
    let awaiting_match = []
    $constructor(code, tokens, error_handler?) {
        this.code = code # The code used by the lexer.
        this.code_lines = this.code.split("\n")
        this.tokens = tokens # The tokens emitted by the lexer.
        this.error_handler = error_handler
    }
    #* Utility *#
    # Gets the token `n` after the current token.
    function peek(n=0)
        return this.tokens.(this.pos + n) if (this.pos + n < this.tokens.length) else null
    
    # Compare the next token with type, value
    function compare(token_type="any", value?, n=0) {
        if this.is_EOF() return false
        let current_token = this.peek(n)
        if current_token & (token_type == "any" | current_token.type == token_type) & (value == null | value == current_token.value)
            return true
        else return false
    }

    # Advance to the next token.
    function advance(n=1) this.pos += n

    # Helper function for error throwing.
    function Throw(type, message, options={}, note="", kill=true, position?, here_message="Here", show=true) {
        let legacy_errors = false
        if legacy_errors {
            if !(options.underline? | options.marker?) {
                options.underline = {
                    start: position.start.column + 1,
                    end: position.end.column + 1
                }
                options.marker = {
                    start: position.start.column + 1,
                    length: 1 + position.end.column - position.start.column
                }
            }
            if !(options.lineno? | options.line_number? | options.linestart?) {
                options.line_number = position.start.line
            }
            this.error_handler.Throw(type, message, options, note, kill)
        }
        let error = ADK_Error(this.error_handler, {
            error_type: type,
            message,
            location: {
                line: position.start.line - 1, # The error formatter starts line counting at 0.
                column: position.start.column - 1, # The error formatter starts column counting at 0.
            },
            markers: options.markers?[{
                line: position.start.line - 1, # The error formatter starts line counting at 0.
                column: position.start.column - 1, # The error formatter starts column counting at 0.
                length: position.end.column - position.start.column + 1,
                message: here_message
            }],
            show,
            ...options
        })
        if store_errors {
            error_stack.add(error)
        } else {
            error.Throw(kill)
        }
        return error
    }


    # Eat all consecutive line breaks
    function eat_line_breaks() while this.compare('LineBreak') this.advance()

    # Is at the end of the file
    function is_EOF() this.pos >= this.tokens.length

    # Throw EOF error
    function throw_EOF_error(expected_token_type="any", expected_token_value?) {
        let current_line = this.code_lines.(-1)
        # Show the expected token if there is one.
        let suggestion
        if expected_token_value
            suggestion = $'"{expected_token_value}"'
        else 
            suggestion = expected_token_type

        let error = this.error_handler.create({
            error_type: "UnexpectedEndOfFile",
            message: "We didn't expect the file to end so soon!",
            location: {
                line: this.code_lines.length - 1,
                column: current_line.length - 1
            },
            markers: [{
                line: this.code_lines.length - 1,
                column: current_line.length,
                length: expected_token_value.length?1,
                message: $"Expected {suggestion}"
            }]
        }, true)
        this.error_stack.add(error)
        return error
    }
    # Consume the current token if type and value match, else throw an error
    function eat(token_type="any", value?, keep_track=false) {
        # If it matches, eat and return it.
        let current_token = this.peek()
        if this.compare(token_type, value) {
            if current_token.value in ["(", "[", "{"] & keep_track {
                this.awaiting_match.add(current_token)
            }
            if current_token.value in [")", "]", "}"] & this.awaiting_match.length > 0 & Parenthesis.(this.awaiting_match.(-1).value) == current_token.value & keep_track {
                this.awaiting_match = this.awaiting_match.slice(0, -1)
            }
            this.advance()
            return current_token
        }
        
        # If we're at the end of the file, throw an error.
        if this.is_EOF()
            return this.throw_EOF_error(token_type, value);
        let show_error = true
        if current_token.value in [")", "]", "}"] & this.awaiting_match.length > 0 & Parenthesis.(this.awaiting_match.(-1).value) == current_token.value & this.error_stack.length > 0 {
            this.awaiting_match = this.awaiting_match.slice(0, -1)
            show_error = false
        }

        # Otherwise, throw an error because it didn't match.
        return this.Throw(
            "Token",
            $"Token {value ? $'of type {token_type}'} expected, but not found.",
            position = this.peek().position
        )
    }
    function maybe_eat(token_type="any", value?)
        this.eat() if this.compare(token_type, value) else null
    
    # Actually parse it
    function parse_primary(Boolean require=false, exclude=[],is_deconstruction=false) {
        let current_token = this.peek()
        let ast_node

        if !current_token | this.is_EOF()
            return this.throw_EOF_error('expression or statement') if require else null;
        
        if this.maybe_eat("String") {
            let value = current_token.value
            let insertions = []
            for insertion in current_token.insertions {
                let new_parser = Parser(insertion.expression_text, insertion.tokens, this.error_handler)
                let insertion_ast_node = new_parser.parse_expression()
                this.error_stack += new_parser.error_stack
                insertions.add({
                    position: insertion.position,
                    ast_node: insertion_ast_node
                })
            }
            ast_node = {
                type: 'StringLiteral',
                value: value,
                insertions,
                position: current_token.position,
                quote_style: current_token.variation
            }
        }
        else if current_token.type in ["Number", "Boolean"] {
            this.eat()
            let value
            if current_token.type == "Boolean"
                value = current_token.value == "true"
            else
                value = Number(current_token.value)
            ast_node = {
                type: current_token.type + 'Literal',
                position: current_token.position,
                value: value,
            }
        }
        else if this.compare('Delimiter', '{') & !exclude.contains('Object') {
            ast_node = CHECK(this.parse_object())
        }

        else if this.compare('Delimiter', '[') & !exclude.contains('Array')
            ast_node = CHECK(this.parse_array(is_deconstruction))
        else if this.compare("Keyword", "set") & this.compare("Delimiter", "{", 1)
            ast_node = CHECK(this.parse_set())
        # Variables
        else if current_token.type == "Identifier" & !exclude.contains('VariableAccess') {
            this.eat()
            ast_node = {
                type: 'VariableAccess',
                name: current_token.value,
                position: current_token.position
            }
        }
        # Statements surrounded by ()
        else if this.maybe_eat('Delimiter', '(') {
            this.eat_line_breaks()
            ast_node = CHECK(this.parse_statement(eat_line_breaks=true))
            this.eat_line_breaks()
            this.eat('Delimiter', ')')
        }
        # 
        if this.compare('Keyword')
        match this.peek().value {
            case 'static' {
                let next_token = this.peek(1)
                if next_token.compare('Keyword', 'private')
                    next_token = this.peek(2)
                if next_token.compare('Keyword', 'function')
                    ast_node = CHECK(this.parse_function_definition())
                else if next_token.compare('Keyword', 'class')
                    ast_node = CHECK(this.parse_class_definition())
                else
                    return this.Throw('SyntaxError', 'Expected "function" or "class" after "static"', position=next_token.position)
            }
            case 'private' {
                let next_token = this.peek(1)
                if next_token.compare('Keyword', 'static')
                    next_token = this.peek(2)
                if next_token.compare('Keyword', 'function')
                    ast_node = CHECK(this.parse_function_definition())
                else if next_token.compare('Keyword', 'class')
                    ast_node = CHECK(this.parse_class_definition())
                else
                    return this.Throw('SyntaxError', 'Expected "function" or "class" after "private"', position=next_token.position)
            }
            case 'function'
                ast_node = CHECK(this.parse_function_definition())
            case 'class'
                ast_node = CHECK(this.parse_class_definition())
            case 'if'
                ast_node = CHECK(this.parse_if_statement())
            case 'while'
                ast_node = CHECK(this.parse_while_statement())
            case 'for'
                ast_node = CHECK(this.parse_for_statement())
            case 'match'
                ast_node = CHECK(this.parse_match_statement())
            case 'await'
                ast_node = CHECK(this.parse_await_statement())
            case 'let'
                ast_node = CHECK(this.parse_assignment())
            case 'layout'
                ast_node = CHECK(this.parse_layout_type())
            case 'embed'
                ast_node = CHECK(this.parse_embed())
            case 'macro'
                ast_node = CHECK(this.parse_function_definition("normal", false, "macro"))
            case $default {
                return this.Throw('SyntaxError', 'Unexpected keyword "' + this.peek().value + '"', position=this.peek().position)
            }
        }

        while ast_node?false {
            if eat_line_breaks
                this.eat_line_breaks()
            # side-by-side multiply (i.e. 2x)
            if this.compare("Identifier") & this.peek().start.column == ast_node.position.end.column + 1 {
                let token = this.eat()
                ast_node = {
                    type: "Multiply",
                    value: ast_node,
                    variable: token.value,
                    position: {
                        start: ast_node.position.start,
                        end: token.end
                    }
                }
            }
            # Function calls
            if this.compare("Delimiter", '(') & this.peek().start.column == ast_node.position.end.column + 1 & !exclude.contains('FunctionCall') {
                ast_node = CHECK(this.parse_function_call(ast_node))
                continue
            }
            # Property access
            if this.compare('Delimiter', '.') {
                ast_node = CHECK(this.parse_property_access(ast_node))
                continue;
            }
            # Re-assignment
            if this.compare("Operator", '=') & !exclude.contains('Reassignment') {
                ast_node = CHECK(this.parse_reassignment(ast_node))
                continue
            }

            # Tell the user that x[] should be x.()
            if this.compare('Delimiter', '[') & this.peek().start.column == ast_node.position.end.column + 1 {
                let opening_bracket = this.eat()
                let inner_node = CHECK(this.parse_expression(eat_line_breaks=true))
                let closing_bracket = CHECK(this.eat('Delimiter', ']'))
                let length
                if opening_bracket.position.start.line == closing_bracket.position.start.line
                    length = closing_bracket.position.end.column - opening_bracket.position.end.column + 1
                else # End of the line
                    length = this.code_lines.(opening_bracket.position.start.line - 1).length - opening_bracket.position.end.column + 1

                return this.Throw("SyntaxError", "Incorrect property access", {
                    markers: [
                        {
                            line: opening_bracket.position.start.line - 1,
                            column: opening_bracket.position.start.column - 1,
                            length,
                            message: "Use `x.(y)` syntax instead of `x[y]`"
                        }
                    ]
                }, position=opening_bracket.position)
            }
            # inline statements. Don't continue because nothing can come after it.
            if this.compare('Keyword') match this.peek().value {
                case 'if'
                    ast_node = CHECK(this.parse_if_statement(ast_node))
                case 'while'
                    ast_node = CHECK(this.parse_while_statement(ast_node))
                case 'for'
                    ast_node = CHECK(this.parse_for_statement(ast_node))
            }
            # Return if none were found
            return ast_node
        }
        if require {
            let show_error = true
            if current_token.value in [")", "]", "}"] & this.awaiting_match.length > 0 & Parenthesis.(this.awaiting_match.(-1).value) == current_token.value & this.error_stack.length > 0 {
                this.awaiting_match = this.awaiting_match.slice(0, -1)
                show_error = false
            }
            return this.Throw('SyntaxError', 'Expected expression or statement', position=this.peek().position, show=show_error)
        }
    }
    function parse_expression(level=keys(OrderOfOps).length-1, require=false, exclude=[], eat_line_breaks=false, is_deconstruction=false) {
        let left = CHECK(this.parse_primary(false, exclude, is_deconstruction) if level < 0 else this.parse_expression(level - 1, false, exclude, eat_line_breaks, is_deconstruction))
        this.eat_line_breaks() if eat_line_breaks;
        let excluded = exclude
        if !excluded.contains("=") excluded += ['=', '->'];
        # while the next token is an operator and level in OrderOfOps, and the value of the next token is in the current precedence level and the value of the next token is not in the exclude list.
        while this.compare('Operator') & level in OrderOfOps & this.peek().value in OrderOfOps.(level) & !(this.peek().value in excluded) {
            let operator = this.eat()
            this.eat_line_breaks() if eat_line_breaks;
            let right = CHECK(this.parse_expression(level - 1, false, excluded, eat_line_breaks, is_deconstruction))
            if !left and !right {
                return this.Throw('SyntaxError', "ðŸ¤¨ That's just an operator with nothing for it to operator on.", position=operator.position)
                # Throw an error because its just an operator all by itself
            }
            left = {
                type: 'Operator',
                left: left,
                right: right,
                operator: operator.value,
                position: {
                    start: left.position.start if left else operator.start,
                    end: right.position.end if right else operator.end
                }
            }
        }
        if !left & require
            left = (CHECK(this.parse_primary(require, excluded, is_deconstruction))) if level < 0 else (CHECK(this.parse_expression(level - 1, require, excluded, eat_line_breaks, is_deconstruction)));
        return left
    }
    function parse_statement(require=false, is_deconstruction=false, mode="normal") {
        this.eat_line_breaks()
        if mode == "class_scope" {
            if this.compare('Delimiter', "$")
                return this.parse_function_definition("class_scope")
            else if this.compare("Keyword", "function")
                return this.parse_function_definition("class_scope")
            else if this.compare("Keyword", "class")
                return this.parse_class_definition()
            else if this.compare("Keyword", "let")
                return this.parse_assignment()
            else
                return this.Throw("SyntaxError", "Not valid in class scope", position=this.peek().position)
        }
        if this.compare('Keyword') match this.peek().value {
            case 'return'
                return this.parse_return_statement()
            case 'break'
                return this.parse_break_statement()
            case 'continue'
                return this.parse_continue_statement()
            case 'defer'
                return this.parse_defer_statement()
            case 'yield'
                return this.parse_yield_statement()
            case 'include'
                return this.parse_include_statement()
            case 'from'
                return this.parse_include_statement()
            case 'extending'
                return this.parse_extending_statement()
        }
        return this.parse_expression(require=require, is_deconstruction=false)
    }
    function parse_program() {
        let body = CHECK(this.parse_scope_body(false))
        return {
            type: "Program",
            body: body.statements,
            position: body.position
        }
    }
    function parse this.parse_program()
    function parse_property_access(ast_node) {
        let dot = this.eat()
        this.eat_line_breaks()
        let property
        if this.compare('Identifier') {
            let token = this.eat()
            property = {
                type: "StringLiteral",
                value: token.value,
                position: token.position
            }
        }
        else if this.compare('Number') {
            let token = this.eat()
            property = {
                type: "NumberLiteral",
                value: Number(token.value),
                position: token.position
            }
        }
        else if this.compare("String") {
            let token = this.eat()
            property = {
                type: "StringLiteral",
                value: token.value,
                position: token.position
            }
        }
        else if this.compare("Delimiter", "(") {
            let token = this.eat()
            property = CHECK(this.parse_statement(eat_line_breaks=true))
            this.eat('Delimiter', ")")
        } else {
            return this.Throw("SyntaxError", "Expected property name", position=this.peek().position)
        }
        return {
            type: "PropertyAccess",
            property: property,
            value: ast_node,
            position: {
                start: ast_node.position.start,
                end: property.position.end
            }
        }
    }
    function parse_embed() {
        this.eat("Keyword", "embed")
        # TODO
    }
    function parse_object() {
        let opening_curly_brace = CHECK(this.eat("Delimiter", "{"))
        let pairs = []
        let expansions = []
        this.eat_line_breaks()
        # While there is no }
        while (this.peek() & !this.compare("Delimiter", "}") & !(this.compare("Delimiter", ",") & this.peek(1).value == "}")) {
            this.eat_line_breaks()
            if pairs.length > 0 
                CHECK(this.eat("Delimiter", ","))
            this.eat_line_breaks()

            # Expansion with ...
            if this.maybe_eat("Operator", "...")
                expansions.add(CHECK(this.parse_expression(require=true)))
            else {
                # TODO: handle $key arbitrary properties
                let key = parse_typed_variable([], ["NumberLiteral", "StringLiteral", "TemplateString"], "object key")
                if type_of(key) == ADK_Error {
                    key.error_number = 1
                    return key
                }
                this.eat_line_breaks()
                let value
                # There is a :, then the value is on the other side
                if this.maybe_eat("Delimiter", ":") {
                    value = CHECK(this.parse_expression(require=true, eat_line_breaks=true))
                } else # Otherwise, the value is a variable access to the key value
                    value = key.variable
                # Should we allow `?` in the key to only be added if it has a value?
                pairs.add({
                    type: "KeyValuePair",
                    key: key.variable,
                    given_type: key.given_type,
                    value,
                    position: {
                        start: key.position.start,
                        end: value.position.end
                    }
                })
            }
        }
        if this.compare("Delimiter", ",")
            this.eat()
        let closing_curly_brace = CHECK(this.eat("Delimiter", "}"))
        return {
            type: "Object",
            pairs,
            expansions,
            position: {
                start: opening_curly_brace.position.start,
                end: closing_curly_brace.position.end
            }
        }
    }
    function parse_array(is_deconstruction=false) {
        let opening_bracket = CHECK(this.eat("Delimiter", "["))
        let items = []
        # While there is no ]
        while (this.peek() & !this.compare("Delimiter", "]") & !(this.compare("Delimiter", ",") & this.peek(1).value == "]")) {
            this.eat_line_breaks()
            if items.length > 0 
                CHECK(this.eat("Delimiter", ","))
            this.eat_line_breaks()
            if is_deconstruction
                items.add(CHECK(this.parse_typed_variable()))
            else
                items.add(CHECK(this.parse_expression(require=true)))
        }
        if this.compare("Delimiter", ",")
            this.eat()
        let closing_bracket = CHECK(this.eat("Delimiter", "]"))
        return {
            type: "Array",
            items,
            position: {
                start: opening_bracket.position.start,
                end: closing_bracket.position.end
            }
        }
    }
    function parse_layout_type() {
        let layout_keyword = CHECK(this.eat("Keyword", `layout`))
        CHECK(this.eat("Delimiter", `(`))
        let type = CHECK(this.parse_expression(require=true))
        this.eat("Delimiter", `)`)
        this.eat_line_breaks()
        let layout_obj = CHECK(this.parse_object())
        return {
            type: "LayoutType",
            layout_type: type,
            "layout": layout_obj,
            position: {
                start: layout_keyword.position.start,
                end: layout_obj.position.end
            }
        }
    }
    function is_valid_type(expression, accept=[], accept_operators=[]) {
        let valid_operators = Set(accept_operators + ["|", "or", "?"])
        if expression == null | accept.contains(expression.type)
            return true
        else if ["VariableAccess", "PropertyAccess", "LayoutType", "Array", "Object", "KeyValuePair"].contains(expression.type) | (expression.type == "Operator" & valid_operators.contains(expression.operator))
        match expression.type {
            case "VariableAccess"
                return true
            case "PropertyAccess"
                return true
            case "LayoutType"
                return true
            case "Array"
                return !expression.items.map(function (x) is_valid_type(x, [], Array(accept_operators)+["..."])).contains(false)
            case "KeyValuePair"
                return is_valid_type(expression.key)
            case "Object"
                return !expression.pairs.map(is_valid_type).contains(false)
            case "Operator"
                return is_valid_type(expression.left) & is_valid_type(expression.right)
        }
        return false
    }
    function is_valid_variable_definition(expression, accept=[], accept_operators=[]) {
        let valid_operators = accept_operators + ["?"]
        if expression == null | accept.contains(expression.type)
            return true
        else if ["VariableAccess", "PropertyAccess", "Array", "Object", "KeyValuePair", "TypedVariable"].contains(expression.type) | (expression.type == "Operator" & valid_operators.contains(expression.operator))
        match expression.type {
            case "VariableAccess"
                return true
            case "PropertyAccess"
                return true
            case "KeyValuePair"
                return is_valid_variable_definition(expression.value)
            case "Array"
                return !expression.items.map(function (x) is_valid_variable_definition(x, [], ["..."])).contains(false)
            case "Object"
                return !expression.pairs.map(is_valid_variable_definition).contains(false)
            case "Operator"
                return is_valid_type(expression.left) & is_valid_type(expression.right)
            case "TypedVariable"
                return true
        }
        return false
    }
    function parse_typed_variable(accept_var=[], name="variable") {
        #* Valid forms:
        Number x
        x y
        layout(Number) {} x
        String this.y
        x
        y
        this.y
        a.b c.d
        etc... you get the idea
        *#
        # This may be the type or the variable, we don't know until we know IF there is a second expression.
        let first = CHECK(this.parse_expression(0, true, ["Reassignment"], false, is_deconstruction=true))
        let second = CHECK(this.parse_expression(0, false, ["Reassignment"], false, is_deconstruction=true))
        if second & !is_valid_type(first) {
            return this.Throw("SyntaxError", "Invalid syntax.", position=first.position, here_message= $"Expected type.")
        } else if !second & !is_valid_variable_definition(first, accept_var) {
            return this.Throw("SyntaxError", $"Invalid syntax.", position=first.position, here_message= $"Expected {name}.")
        } else if second & !is_valid_variable_definition(second, accept_var) {
            return this.Throw("SyntaxError", $"Invalid syntax.", position=second.position, here_message= $"Expected {name}.")
        }

        return {
            type: "TypedVariable",
            given_type: first if second else null,
            variable: second?first,
            position: {
                start: first.position.start,
                end: second.position.end if second else first.position.end
            }
        }


    }
    function parse_assignment() {
        let let_keyword = CHECK(this.eat("Keyword", "let"))
        let is_embed_assignment = false
        if this.maybe_eat("Operator", "%") {
            is_embed_assignment = true
        }
        assignments = []
        while true {
            if assignments.length > 0
                CHECK(this.eat("Delimiter", ","))
            let is_static = false
            let is_private = false
            # Allow static and private in any order
            if this.maybe_eat("Keyword", "static")
                is_static = true
            if this.maybe_eat("Keyword", "private")
                is_private = true
            if this.maybe_eat("Keyword", "static")
                is_static = true
            let variables = []
            variables.add(CHECK(this.parse_typed_variable()))
            let value
            # TODO: allow chaining: let x = y = 5
            if this.maybe_eat("Operator", "=")
                value = CHECK(this.parse_expression(require=true, exclude=["Reassignment"]))
            assignments.add({
                type: "Assignment",
                variables,
                value: value?,
                is_static: is_static,
                is_private: is_private,
                position: {
                    start: variables.0.position.start,
                    end: value.position.end if value? else variables.(-1).position.end
                }
            })
            if !this.compare("Delimiter", ",") break
        }
        return {
            type: "Assignments",
            assignments,
            is_embed_assignment,
            position: {
                start: let_keyword.position.start,
                end: assignments.(-1).position.end
            }
        }
    }
    function parse_function_definition(mode="normal", found_static=false, expected_keyword="function") {
        let is_static = found_static
        let is_private = false
        let parameters = []
        let first_keyword, label, name, return_type, body, parameter_expansion, function_keyword
        if this.compare("Keyword", "static") {
            first_keyword = this.eat()
            is_static = true
        }
        if this.compare("Keyword", "private") {
            let keyword = this.eat()
            if (!first_keyword?)
                first_keyword = keyword
            is_private = true
        }
        if this.compare("Keyword", "static") {
            let keyword = this.eat()
            if (!first_keyword?) 
                first_keyword = keyword
            is_static = true
        }
        # the function keyword is required unless we're in a class scope or extending 
        if !["extending", "class_scope"].contains(mode)
            function_keyword = CHECK(this.eat("Keyword", expected_keyword))
        else # Otherwise it's optional
            function_keyword = this.maybe_eat("Keyword", expected_keyword)
        
        if mode == "class_scope" & this.compare("Delimiter", "$") {
            function_keyword = this.eat()
            let token = CHECK(this.eat("Identifier"))
            name = {
                type: "VariableAccess",
                name: '$' + token.value,
                position: token.position
            }
        }

        if (!first_keyword? & function_keyword?)
            first_keyword = function_keyword

        if !(name?) & this.compare("Identifier") {
            let token = this.eat()
            name = {
                type: "VariableAccess",
                name: token.value,
                position: token.position
            }
        }

        if (!first_keyword? & name?)
            first_keyword = name

        if this.compare("Delimiter", "(") {
            let opening_parenthesis = this.eat()
            if (!first_keyword?)
                first_keyword = opening_parenthesis
            while !this.compare("Delimiter", ")") {
                if parameters.length > 0 CHECK(this.eat("Delimiter", ","))
                if this.compare("Operator", "...") {
                    let operator = this.eat()
                    parameter_expansion = CHECK(this.parse_primary(true))
                    if !["VariableAccess", "PropertyAccess"].contains(parameter_expansion.type) 
                        return this.Throw("SyntaxError", "Invalid syntax.", position=parameter_expansion.position, here_message= $"Expected parameter name.")
                    # An expansion MUST be the last parameter
                    break
                }
                parameters.add(CHECK(this.parse_typed_variable()))
            }
            if this.compare("Delimiter", ",") this.eat()
            let closing_parenthesis = this.eat("Delimiter", ")")
        }
        # Parse labels
        if this.maybe_eat("Keyword", "as")
            label = CHECK(this.eat("Identifier"))

        # Parse return type
        if this.compare("Operator", "->") {
            let operator = this.eat()
            if (!first_keyword?)
                first_keyword = operator
            return_type = CHECK(this.parse_primary(require=true))
            if !this.is_valid_type(return_type) {
                return this.Throw("SyntaxError", "Invalid syntax.", position=return_type.position, here_message= $"Expected type.")
            }
        }
        body = CHECK(this.parse_statement_or_scope_body())
        return {
            type: "FunctionDefinition" if expected_keyword == "function" else if expected_keyword == "macro" "MacroDefinition",
            name: name?,
            parameters,
            parameter_expansion: parameter_expansion?,
            return_type: return_type?,
            body,
            label: label?,
            is_static,
            is_private,
            position: {
                start: first_keyword.position.start if first_keyword? else body.position.start,
                end: body.position.end
            }

        }
    }
    function parse_statement_or_scope_body(mode="normal") {
        let body
        if this.compare("Delimiter", "{") {
            let previous_store_errors_state = this.store_errors
            this.store_errors = true
            let previous_position = this.pos
            body = this.parse_object()
            this.store_errors = previous_store_errors_state
            if type_of(body) == ADK_Error & body.error_number == 1 {
                this.pos = previous_position
                this.error_stack.(-1).Throw()
                this.error_stack = this.error_stack.slice(0, -1)
                extension = CHECK(this.parse_scope_body(true, mode))
            }
        } else {
            body = CHECK(this.parse_statement(require=true))
        }
        return body
    }
    function parse_if_statement(ast_node) {
        # ast_node is provided if the body comes before the if keyword. That is, it is an inline if statement.
        # x if y else z
        let if_keyword = CHECK(this.eat("Keyword", "if"))
        let condition = CHECK(this.parse_expression(require=true))
        let body, else_body
        if ast_node 
            body = ast_node
        body = CHECK(this.parse_statement_or_scope_body())
        this.eat_line_breaks()
        # Handle else statements
        if this.compare("Keyword", "else") {
            let else_keyword = this.eat()
            else_body = CHECK(this.parse_statement_or_scope_body())
        }
        return {
            type: "IfStatement",
            condition,
            body,
            else_body: else_body?,
            position: {
                start: if_keyword.position.start,
                end: else_body.position.end if else_body? else body.position.end
            }
        }
    }
    function parse_class_definition() {
        let name, label
        let is_static = false
        let is_private = false
        if this.maybe_eat("Keyword", "static")
            is_static = true
        if this.maybe_eat("Keyword", "private")
            is_private = true
        if this.maybe_eat("Keyword", "static")
            is_static = true
        let class_keyword = CHECK(this.eat("Keyword", "class"))
        if this.compare("Identifier") {
            let token = this.eat()
            name = {
                type: "VariableAccess",
                name: token.value,
                position: token.position
            }
        }
        if this.maybe_eat("Keyword", "as") 
            label = CHECK(this.eat("Identifier"))
        let body = CHECK(this.parse_scope_body(true, "class_scope"))
        return {
            type: "ClassDefinition",
            name: name?,
            body,
            label: label?,
            is_static,
            is_private,
            position: {
                start: class_keyword.position.start,
                end: body.position.end
            }
        }
    }
    function parse_return_statement() {
        let return_keyword = CHECK(this.eat("Keyword", "return"))
        let value = CHECK(this.parse_expression(require=true))
        return {
            type: "ReturnStatement",
            value,
            position: {
                start: return_keyword.position.start,
                end: value.position.end
            }
        }
    }
    function parse_continue_statement() {
        let continue_keyword = CHECK(this.eat("Keyword", "continue"))
        return {
            type: "ContinueStatement",
            position: {
                start: continue_keyword.position.start,
                end: continue_keyword.position.end
            }
        }
    }
    function parse_break_statement() {
        let break_keyword = CHECK(this.eat("Keyword", "break"))
        return {
            type: "BreakStatement",
            position: {
                start: break_keyword.position.start,
                end: break_keyword.position.end
            }
        }
    }
    function parse_yield_statement() {
        let yield_keyword = CHECK(this.eat("Keyword", "yield"))
        let value = CHECK(this.parse_expression(require=true))
        return {
            type: "YieldStatement",
            value,
            position: {
                start: yield_keyword.position.start,
                end: value.position.end
            }
        }
    }
    function parse_defer_statement() {
        let defer_keyword = CHECK(this.eat("Keyword", "defer"))
        let value = CHECK(this.parse_expression(require=true))
        return {
            type: "DeferStatement",
            value,
            position: {
                start: defer_keyword.position.start,
                end: value.position.end
            }
        }
    }
    function parse_include_statement() {
        # include x, y, z from a
        # include x as b, y as b, z
        # include x as y
        # from x include a, b, c as d
        # from x include {x: a, y: b, z}
        # include {x: a, y: b, z}
        # include {x: a, y: b, z} from x
        # include [a, b, c] from x
        # include [a, b, c]
        # include [a, b, c] as d from x
        # include {x: a, y: b, z} as d from x
        # from x include [a, b, c]
        let starting_keyword
        let global_origin
        if this.compare("Keyword", "from") {
            starting_keyword = this.eat()
            if this.compare("Identifier")
                global_origin = this.eat()
            else if this.compare("String")
                global_origin = this.eat()
            else if this.compare("Number")
                global_origin = this.eat()
            else
                return this.Throw("SyntaxError", "Expected 'Identifier' or 'String'.", position=this.peek().position, here_message="That is not a library name, at least not one that the compiler can recognize.")
        }
        if this.compare("Keyword", "include") {
            starting_keyword = this.eat()
            let included_things = []
            while !(this.compare("Delimiter", "from") | this.compare("LineBreak")) & this.peek() {
                let thing, name, origin
                if included_things.length > 0
                    CHECK(this.eat("Delimiter", ","))
                if this.compare("Delimiter", "[") {
                    let array = CHECK(this.parse_array(true))
                    # TODO
                    thing = array
                } else if this.compare("Delimiter", "{") {
                    let object = CHECK(this.parse_object())
                    # TODO
                    thing = object
                } else if this.compare("Identifier") {
                    thing = this.eat().value
                    name = thing
                } else if this.compare("String") {
                    thing = this.eat().value
                    name = thing
                }
                if this.maybe_eat("Keyword", "as") {
                    name = CHECK(this.eat("Identifier"))
                }
                if this.maybe_eat("Keyword", "from") {
                    if (global_origin?) {
                        let cause = this.peek(1)?this.peek()
                        return this.Throw("SyntaxError", "Unexpected 'from'.", {
                            markers: [
                            {
                                line: global_origin.position.start.line - 1,
                                column: global_origin.position.start.column - 1,
                                length: global_origin.position.end.column - global_origin.position.start.column + 1,
                                message: "You told us where to include this stuff this library."
                            },
                            {
                                line: cause.position.start.line - 1,
                                column: cause.position.start.column - 1,
                                length: cause.position.end.column - cause.position.start.column + 1,
                                message: "So what is this supposed to mean? I'm a compiler you know, I can't just read your thoughts."
                            }
                        ]
                        }, position=this.peek().position)
                    }
                    origin = CHECK(this.eat("Identifier"))
                }
                included_things.add({
                    type: "IncludedThing",
                    thing: thing?,
                    name: name?,
                    origin: (origin?(global_origin?)).value?null,
                }) # TODO: add position?
            }
            return {
                type: "IncludeStatement",
                included_things,
                position: {
                    start: starting_keyword.position.start,
                    end: this.peek(-1).position.end
                }
            }
        } else if this.compare("Keyword", "from") {
            starting_keyword = this.eat()
            # TODO!
        } else
            return this.Throw("SyntaxError", "Expected 'include' or 'from'.", position=this.peek().position)
        # TODO

    }
    function parse_extending_statement() {
        let extending_keyword = CHECK(this.eat("Keyword", "extending"))
        let object, extension
        let is_static = false
        if this.compare("Keyword", "static") & this.compare("Keyword", "function", 1) | this.compare("Keyword", "function")
            extension = CHECK(this.parse_function_definition())
        else if this.compare("Keyword", "static") & this.compare("Keyword", "class", 1) | this.compare("Keyword", "class")
            extension = CHECK(this.parse_class_definition())
        if (extension?) {
            if (!extension.name?)
                return this.Throw("ExtensionError", "Cannot extend something anonymous.", position=extension.position, here_message="Anonymous")
            return {
                type: "ExtendingStatement",
                object: extension.name,
                extension,
                position: {
                    start: extending_keyword.position.start,
                    end: extension.position.end
                }
            }
        }
        if this.maybe_eat("Keyword", "static")
            is_static = true
        if this.compare("Identifier") {
            # Needs to handle x, x.y, x.(y)
            let identifier = this.eat()
            object = {
                type: "VariableAccess",
                name: identifier.value,
                position: identifier.position
            }
            if this.compare('Delimiter', '.') & this.peek().start.column == ast_node.position.end.column + 1 {
                object = CHECK(this.parse_property_access(object))
            }
        } else if this.compare("Operator") {
            let operator = this.eat()
            object = {
                type: "OperatorValue",
                value: operator.value,
                position: operator.position
            }
        }
        if this.compare("Operator", "->") {
            let operator = this.eat()
            let type = CHECK(this.parse_primary(require=true))
            if !this.is_valid_type(type) {
                return this.Throw("SyntaxError", "Invalid syntax.", position=type.position, here_message= $"Expected type.")
            }
            let body = CHECK(this.parse_statement_or_scope_body())
            extension = {
                type: "FunctionDefinition",
                name: object,
                type: type,
                parameters: [],
                parameter_expansion: null,
                is_static: is_static,
                is_private: null,
                body: body,
                position: {
                    start: object.position.start,
                    end: body.position.end
                }
            }
        } else if this.compare("Delimiter", "(") {
            extension = CHECK(this.parse_function_definition("extending", is_static))
        } else if this.compare("Delimiter", "[") {
            extension = CHECK(this.parse_array())
        } else {
            extension = CHECK(this.parse_statement_or_scope_body())
        }


        return {
            type: "ExtendingStatement",
            object,
            extension,
            position: {
                start: extending_keyword.position.start,
                end: extension.position.end
            }
        }
    }
    function parse_function_call(ast_node) {
        let opening_parenthesis = CHECK(this.eat("Delimiter", "("))
        let arguments = []
        let keyword_arguments = []
        while !this.compare("Delimiter", ")") {
            if arguments.length > 0 | keyword_arguments.length > 0
                CHECK(this.eat("Delimiter", ","))
            let value = CHECK(this.parse_expression(exclude=['Reassignment']))
            if this.maybe_eat("Operator", "=") {
                let key = value
                if !this.is_valid_variable_definition(key)
                    return this.Throw("SyntaxError", $"Invalid syntax.", position=first.position, here_message= $"Expected parameter name.")
                let value = CHECK(this.parse_expression())
                keyword_arguments.add({
                    type: "KeyValuePair",
                    key: key,
                    value,
                    position: {
                        start: key.position.start,
                        end: value.position.end
                    }
                })
            } else 
                arguments.add(value)
        }
        if this.compare("Delimiter", ",") this.eat()
        let closing_parenthesis = this.eat("Delimiter", ")")
        return {
            type: "FunctionCall",
            object: ast_node,
            arguments,
            keyword_arguments,
            position: {
                start: opening_parenthesis.position.start,
                end: closing_parenthesis.position.end
            }
        }
    }
    function parse_reassignment(ast_node) {
        if !this.is_valid_variable_definition(ast_node) {
            return this.Throw("SyntaxError", $"Invalid syntax.", position=ast_node.position, here_message= $"Expected identifier (variable or property).")
        }
        let objects = [ast_node]
        let value
        # Reassignment chaining, x = y = z
        while true {
            CHECK(this.eat("Operator", "="))
            if (value?) {
                if !this.is_valid_variable_definition(ast_node) {
                    return this.Throw("SyntaxError", $"Invalid syntax.", position=ast_node.position, here_message= $"Expected identifier (variable or property).")
                }
                objects.add(value)
            }
            value = CHECK(this.parse_expression(require=true, exclude=["Reassignment"]))
            if !this.compare("Operator", "=") break
        }

        return {
            type: "Reassignment",
            objects,
            value,
            position: {
                start: ast_node.position.start,
                end: value.position.end
            }
        }
    }
    function parse_scope_body(enclosing_curly_braces=true, mode="normal") {
        let beginning_token = this.peek()
        let opening_curly_brace, closing_curly_brace
        if enclosing_curly_braces 
            opening_curly_brace = CHECK(this.eat("Delimiter", "{"))
        let statements = []
        while (!enclosing_curly_braces | !this.compare("Delimiter", "}")) & !this.is_EOF() {
            if statements.length > 0 & this.peek(-1).type != 'LineBreak' CHECK(this.eat('LineBreak'))
            this.eat_line_breaks()
            if this.is_EOF() | (enclosing_curly_braces & this.compare("Delimiter", "}")) break;
            let statement
            while !(statement? | this.is_EOF() | (this.compare("Delimiter", "}") & enclosing_curly_braces)) {
                statement = this.parse_statement(true, false, mode)
                if type_of(statement) == ADK_Error {
                    while !this.is_EOF() {
                        this.eat(keep_track=true)
                        if this.compare("LineBreak") | this.is_EOF() break
                    }
                    this.eat_line_breaks()
                    statement = null;
                }
            }
            if !(statement?) break
            statements.add(statement)
        }

        if enclosing_curly_braces 
            closing_curly_brace = CHECK(this.eat("Delimiter", "}"))

        let start_position, end_position
        if !enclosing_curly_braces & this.is_EOF() & statements.length == 0 {
            # There was nothing here at all
            start_position = null 
            # It has no start and no end, because it is nothing.
            end_position = null
        } else if !enclosing_curly_braces & this.is_EOF() & statements.length > 0 {
            # There was something, but it ended with an EOF
            start_position = statements.0.position.start
            end_position = this.peek(-1).position.end
        } else if !enclosing_curly_braces & statements.length == 0 {
            # There wasn't anything here, but there's more to the file.
            start_position = null 
            # It has no start and no end, because it is nothing.
            end_position = null
        } else if !enclosing_curly_braces & statements.length > 0 {
            # There was something here, but no curly braces to enclose it. There was no EOF.
            start_position = beginning_token ? statements.0.position.start
            end_position = this.peek(-1).position.end
        } else if enclosing_curly_braces {
            # It was enclosed, so the start is the opening curly brace and the end is the closing
            start_position = opening_curly_brace.position.start
            end_position = closing_curly_brace.position.end
        } 
        return {
            type: "ScopeBody",
            statements,
            position: {
                start: start_position,
                end: end_position
            }
        }
    }
}

# Comment out the ones we are not working on to save test time.
let parser_tests = {
    empty_object: "{\n\n}",
    empty_scope: "\n\n",
    property_access: "x.y.z",
    function_definition: "private static function x(Number x, y, {Number a, b, c:d}, [String a, b, c], this.y, ...args) -> Number {\n\n}",
    macro_definition: "macro x(y) {}",
    simple_function_definition: "function x {}",
    if_else_statement: "if condition {\n\n x\n\n\n } else if condition { \ny\n } \n\nelse { z }",
    object_type: "let {Number x, String y} x",
    optional_type: "let String? x",
    optional_type_no_annotations: "let x? = y",
    typed_deconstruction: "let [String a, b, Number c] = x",
    object: "{x: 5, y: 6, Number z: 7, d, ...y}",
    array_extending: "extending x [5, 6, 7, 8, 9, 10]",
    function_extending: "extending x(y, z) -> Number {}",
    function_extending_no_parameters: "extending x {}",
    function_extending_no_parameters_with_return_type_annotation: "extending x -> Number {}",
    object_extending: "extending x {y: 5, z: 6}",
    operator_extending: "extending +(Number x, String y) -> String {}",
    reassignment: "x = y = z = 5",
    template_string: "$'Hello, {name}!'",
    multiline_property_access: "x.\n    y.\n    z",
    class_definition: "private static class x as this {\n\n$constructor() {}\n\nfunction $constructor() {}\nfunction method() {}\nlet x = 5\n let y}",
    empty_class: "class {\n\n\n}",
    function_call: "x(x, y, ...z, a=b, c=d, {e, f:g})",
    simple_include: "include x",

}
let error_tests = {
    multiple_decimal_points: "5.4.3",
    multiple_underscore: "5_4_3",
    assign_value: "let 5 = x",
    else_without_if: "else { x }",
    anonymous_function_extension: "extending function {}",
    many_errors: "5.4.3\n5_4_3\nlet 5 = x\n\nelse {}\n\n",
    expression_in_class_scope: "class x {\nstdout.log(5 * 5)\n}", 
    include_double_from: "from x include y from z",
}
function test(String code) {
    let lexer = Lexer(false, false)
    let tokens = lexer.tokenize(code)
    let error_handler = ErrorHandler(code, tokens, '<main>')
    error_handler.tokens = tokens
    # stdout.write(tokens, '\n')
    let parser = Parser(code, tokens, error_handler)
    let AST = parser.parse()
    # stdout.write("AST", AST, "\n")
    for error in lexer.error_stack + parser.error_stack {
        if type_of(error) != ADK_Error 
            error = ADK_Error(error_handler, error)
        if error.show {
            error.Throw()
        }
    }
    if parser.error_stack.length > 0 | lexer.error_stack.length > 0
        return false
    return AST
}
# test(error_tests.anonymous_function_extension)
if is_main {
    # stdout.log(test(error_tests.expression_in_class_scope))
    for test_name:code in parser_tests {
        # ultimate += code + "\n"
        let passed = test(code)
        # stdout.log(passed)
        if passed
            stdout.log("PASSED:", test_name)
        else
            stdout.log("FAILED:", test_name)
    }

    # for test_name:code in error_tests {
    #     test(code)
    # }
}