from Data include OrderOfOps
include Token, Lexer from Lexer
include ErrorHandler from Errors


static class Parser as this {
    let String code
    let [...String] code_lines
    let [...Token] tokens
    let Number pos = 0
    let [ErrorHandler, null] error_handler
    let Lexer lexer
    $constructor(Lexer lexer, error_handler=null) {
        this.code = lexer.data # The code used by the lexer.
        this.code_lines = this.code.split("\n")
        this.tokens = lexer.output # The tokens emitted by the lexer.
        this.error_handler = error_handler
        this.lexer = lexer
    }
    #* Utility *#
    # Gets the token `n` after the current token.
    function peek(n=0)
        return this.tokens.(this.pos + n) if (this.pos + n < this.tokens.length) else null
    
    # Compare the next token with type, value
    function compare(token_type="any", value=null, n=0) {
        if this.is_EOF() return false
        let current_token = this.peek(n)
        if current_token & (token_type == "any" | current_token.type == token_type) & (value == null | value == current_token.value)
            return true
        else return false
    }

    # Advance to the next token.
    function advance(n=1) this.pos += n

    # Helper function for error throwing.
    function Throw(type, message, options={}, note="", kill=true, position=null) {
        let legacy_errors = false
        if legacy_errors {
            if !(options.underline? | options.marker?) {
                options.underline = {
                    start: position.start.column + 1,
                    end: position.end.column + 1
                }
                options.marker = {
                    start: position.start.column + 1,
                    length: 1 + position.end.column - position.start.column
                }
            }
            if !(options.lineno? | options.line_number? | options.linestart?) {
                options.line_number = position.start.line
            }
            this.error_handler.Throw(type, message, options, note, kill)
        }
        this.error_handler.ThrowNew({
            error_type: type,
            message,
            location: position.start,
            markers: [{
                line: position.start.line - 1, # The error formatter starts line counting at 0.
                column: position.start.column - 1, # The error formatter starts column counting at 0.
                length: position.end.column - position.start.column,
                message: "Here"
            }]
        }, kill)
    }


    # Eat all consecutive line breaks
    function eat_line_breaks() while this.compare('LineBreak') this.advance()

    # Is at the end of the file
    function is_EOF() this.pos >= this.tokens.length

    # Throw EOF error
    function throw_EOF_error(expected_token_type="any", expected_token_value=null) {
        let current_line = this.code_lines.(-1)
        
        # Show the expected token if there is one.
        let suggestion = expected_token_value?$"<{expected_token_type}>"

        this.error_handler.Throw(
            "EOF",
            "Unexpected EOF.",
            {
                line_number: this.code_lines.length - 1,
                did_you_mean: (current_line + suggestion) if expected_token_type != "any" else null
            }
        )
    }
    # Consume the current token if type and value match, else throw an error
    function eat(token_type="any", value=null) {
        # If it matches, eat and return it.
        if this.compare(token_type, value) {
            let current_token = this.peek()
            this.advance()
            return current_token
        }
        
        # If we're at the end of the file, throw an error.
        if this.is_EOF()
            return this.throw_EOF_error(token_type, value);

        # Otherwise, throw an error because it didn't match.
        this.Throw(
            "Token",
            $"Token {value ? $'of type {token_type}'} expected, but not found.",
            position = this.peek().position
        )
    }
    
    # Actually parse it
    function parse_primary(Boolean require=false) {
        let current_token = this.peek()
        let Object ast_node
        if !current_token | this.is_EOF()
            return this.EOFError('Value') if require else null;
        
        # Template Strings
        else if this.compare('Operator', '$') & this.peek(1).compare('String', null, 2) {
            let start = this.eat()
            let string = this.eat()

            let template_string = string.value
            let text = ""
            let index = 0
            let replacements = []
            while index < template_string.length {
                # Handles {{
                if template_string.(index) == "{" & index + 1 < template_string.length & template_string.(index + 1) == "{" {
                    index += 2
                    text += "{"
                }
                # If we hit a {
                else if template_string.(index) == "{" {
                    index++
                    let start_index = index
                    let inner = ""
                    let opener_count = 1
                    
                    # Loop until the string ends or the { is closed
                    while index < template_string.length & opener_count > 0 {
                        if template_string.(index) == "{" opener_count++
                        else if template_string.(index) == "}" opener_count--
                        if opener_count == 0 break
                        inner += template_string.(index)
                        index++
                    }

                    if opener_count > 0 {
                        # Throw error, replacement never closed
                        this.throw_EOF_error('Delimiter', '}')
                    }

                    if inner == "" {
                        # Throw error, empty replacement
                        this.throw_EOF_error('')
                    }
                    # Cut off the }
                    inner = inner.slice(0, -1)
                    # Tokenize the code inside {}
                    let inner_tokens = this.lexer.tokenize(inner)
                    # Save current state
                    let saved_tokens = this.tokens
                    let saved_pos = this.pos
                    # Reset State to parse
                    this.tokens = inner_tokens
                    this.pos = 0
                    # Parse
                    inner_ast = this.pExpression()
                    # Restore State
                    this.tokens = saved_tokens
                    this.pos = saved_pos

                    replacements.add({"from": start_index, "to": index, "value": inner_ast, "string": inner})
                }
                else
                    text += template_string.(index)

                index++
            }
            ast_node = {
                type: "TemplateString",
                position: {start: start.start, end: string.end},
                value: string.value,
                replacements: replacements
            }
        }
        else if current_token.type in ["String", "Number", "Boolean"] {
            this.eat()
            let value
            if current_token.type == "String"
                value = current_token.value
            else if current_token.type == "Boolean"
                value = current_token.value == "true"
            else
                value = Number(current_token.value)
            ast_node = {
                type: current_token.type + 'Literal',
                position: current_token.position,
                value: value
            }
        }
        else if this.compare('Delimiter', '{') 
            ast_node = this.parse_object()

        else if this.compare('Delimiter', '[') 
            ast_node = this.parse_array()
        
        # Variables
        else if current_token.type == "Identifier" {
            this.eat()
            if current_token.value == "set" & this.compare("Delimiter", "{")
                ast_node = this.parse_set();
            else 
                ast_node = {
                    type: 'VariableAccess',
                    value: current_token.value,
                    position: current_token.position
                }
        }
        # Statements surrounded by ()
        else if this.compare('Delimiter', '(') {
            this.eat()
            this.eat_line_breaks()
            ast_node = this.parse_statement(eat_line_breaks=true)
            this.eat_line_breaks()
            this.eat('Delimiter', ')')
        }

        else if this.compare('Keyword', 'static') {
            let next_token = this.peek()
            if next_token.compare('Keyword', 'function')
                ast_node = this.parse_function_definition()
            else if next_token.compare('Keyword', 'class')
                ast_node = this.parse_class_definition()
            else
                this.Throw('SyntaxError', 'Expected "function" or "class" after "static"', position=next_token.position)
        }
        else if this.compare('Keyword') match this.peek().value {
            case 'function'
                ast_node = this.parse_function_definition()
            case 'class'
                ast_node = this.parse_class_definition()
            case 'if'
                ast_node = this.parse_if_statement()
            case 'while'
                ast_node = this.parse_while_statement()
            case 'for'
                ast_node = this.parse_for_statement()
            case 'match'
                ast_node = this.parse_match_statement()
            case 'await'
                ast_node = this.parse_await_statement()
            case 'let'
                ast_node = this.parse_assignment()
            case 'layout'
                ast_node = this.parse_layout()
        }

        while ast_node?false {
            # side-by-side multiply (i.e. 2x)
            if this.compare("Identifier") & this.peek().start.column == ast_node.position.end.column + 1 {
                let token = this.eat()
                ast_node = {
                    type: "Multiply",
                    value: ast_node,
                    variable: token.value,
                    position: {
                        start: ast_node.position.start,
                        end: token.end
                    }
                }
            }
            # Function calls
            if this.compare("Delimiter", '(') & this.peek().start.column == ast_node.position.end.column + 1 {
                ast_node = this.pFunctionCall(ast_node)
                continue
            }
            # Property access
            if this.compare('Delimiter', '.') {
                this.eat()
                let property_name = this.eat('Identifier')
                ast_node = {
                    type: "PropertyAccess",
                    property: property_name.value,
                    value: ast_node,
                    position: {
                        start: ast_node.position.start,
                        end: property_name.end
                    }
                }
                continue;
            }
            # inline statements. Don't continue because nothing can come after it.
            if this.compare('Keyword') match this.peek().value {
                case 'if'
                    ast_node = this.parse_if_statement(ast_node)
                case 'while'
                    ast_node = this.parse_while_statement(ast_node)
                case 'for'
                    ast_node = this.parse_for_statement(ast_node)
            }
            # Return if none were found
            return ast_node
        }
        if require {
            this.Throw('SyntaxError', 'Expected expression or statement', position=this.peek().position)
        }
    }
    function parse_expression(level=keys(OrderOfOps).length-1, require=false, exclude=[], eat_line_breaks=false) {
        let left = this.parse_primary(false) if level < 0 else this.parse_expression(level - 1, false, exclude, eat_line_breaks)
        this.eat_line_breaks() if eat_line_breaks;
        if !exclude.contains("$") exclude.add("$");
        # while the next token is an operator and level in OrderOfOps, and the value of the next token is in the current precedence level and the value of the next token is not in the exclude list.
        while this.compare('Operator') & level in OrderOfOps & this.peek().value in OrderOfOps.(level) & !(this.peek().value in exclude) {
            let operator = this.eat()
            this.eat_line_breaks() if eat_line_breaks;
            let right = this.parse_expression(level - 1, false, exclude, eat_line_breaks)
            if !left and !right {
                this.Throw('SyntaxError', "🤨 That's just an operator with nothing for it to operator on.", position=operator.position)
                # Throw an error because its just an operator all by itself
            }
            left = {
                type: 'Operator',
                left: left,
                right: right,
                operator: operator.value,
                position: {
                    start: left.position.start if left else operator.start,
                    end: right.position.end if right else operator.end
                }
            }
        }
        if !left & require
            left = (this.parse_primary(require)) if level < 0 else (this.parse_expression(level - 1, require, exclude, eat_line_breaks));
        return left
    }
    function parse_statement(require=false) {
        this.eat_line_breaks()
        if this.compare('Keyword') match this.peek().value {
            case 'return'
                return this.parse_return_statement()
            case 'break'
                return this.parse_break_statement()
            case 'continue'
                return this.parse_continue_statement()
            case 'defer'
                return this.parse_defer_statement()
            case 'yield'
                return this.parse_yield_statement()
            case 'include'
                return this.parse_include_statement()
        }
        return this.parse_expression(require=require)
    }
    function parse_program() {
        statements = []
        while !this.is_EOF() {
            if statements.length > 0 & this.peek(-1).type != 'LineBreak' this.eat('LineBreak')
            this.eat_line_breaks()
            if this.is_EOF() break;
            statements.add(this.parse_statement(true))
        }
        return {
            type: "Program",
            body: statements,
            position: {
                start: 0 if statements.length == 0 else statements.0.position.start,
                end: 0 if statements.length == 0 else statements.(-1).position.end
            }
        }
    }
    function parse this.parse_program()
    function parse_function_call(ast_node) {

    }
    function parse_object() {
        let opening_curly_brace = this.eat("Delimiter", "{")
        let pairs = []
        let expansions = []
        # While there is no }
        while (this.peek() & !this.compare("Delimiter", "}") & !(this.compare("Delimiter", ",") & this.peek(1).value == "}")) {
            this.eat_line_breaks()
            if pairs.length > 0 this.eat("Delimiter", ",")
            this.eat_line_breaks()

            # Expansion with ...
            if this.compare("Operator", "...") {
                this.eat()
                expansions.add(require=true)
            } else {
                # TODO: handle types in the Object!
                let key = parse_typed_variable([], ["NumberLiteral", "StringLiteral"], "object key")
                this.eat_line_breaks()
                let value
                # There is a :, then the value is on the other side
                if this.compare("Delimiter", ":") {
                    this.eat()
                    this.eat_line_breaks()
                    value = this.parse_expression(require=true)
                } else # Otherwise, the value is a variable access to the key value
                    value = {
                        type: "VariableAccess",
                        value: key,
                        position: key.position
                    }
                pairs.add({
                    type: "KeyValuePair",
                    key,
                    value,
                    position: {
                        start: key.position.start,
                        end: value.position.end
                    }
                })
            }
        }
        if this.compare("Delimiter", ",")
            this.eat()
        let closing_curly_brace = this.eat("Delimiter", "}")
        return {
            type: "Object",
            pairs,
            expansions,
            position: {
                start: opening_curly_brace.position.start,
                end: closing_curly_brace.position.end
            }
        }
    }
    function parse_layout_type() {
        let layout_keyword = this.eat("Keyword", `layout`)
        this.eat("Delimiter", `(`)
        let type = this.parse_expression(require=true)
        this.eat("Delimiter", `)`)
        this.eat_line_breaks()
        let layout = this.parse_object()
        return {
            type: "LayoutType",
            layout_type: type,
            layout,
            position: {
                start: layout_keyword.position.start,
                end: layout.position.end
            }
        }
    }
    function is_valid_type(expression, accept=[]) {
        if expression == null | accept.contains(expression.type)
            return true
        if ["VariableAccess", "PropertyAccess", "LayoutType", "Array"].contains(expression.type) | (expression.type == "Operator" & ["|", "or"].contains(expression.operator))
        match expression.type {
            case "VariableAccess"
                return true
            case "PropertyAccess"
                return true
            case "LayoutType"
                return true
            case "Array"
                return !expression.items.map(is_valid_type).contains(false)
            case "Operator"
                return is_valid_type(expression.left) & is_valid_type(expression.right)
        }
        return false
    }
    function is_valid_variable_definition(expression, accept=[]) {
        if expression == null | accept.contains(expression.type)
            return true
        else if ["VariableAccess", "PropertyAccess", "Array", "Object", "KeyValuePair"].contains(expression.type) match expression.type {
            case "VariableAccess"
                return true
            case "PropertyAccess"
                return true
            case "KeyValuePair"
                return is_valid_variable_definition(expression.value)
            case "Array"
                return !expression.items.map(is_valid_variable_definition).contains(false)
            case "Object"
                return !expression.pairs.map(is_valid_variable_definition).contains(false)
        }
        return false
    }
    function parse_typed_variable(accept_type=[], accept_var=[], name="variable") {
        #* Valid forms:
        Number x
        x y
        layout(Number) {} x
        String this.y
        x
        y
        this.y
        a.b c.d
        *#
        # This may be the type or the variable, we don't know until we know IF there is a second expression.
        let first = this.parse_primary(require=true)
        let second = this.parse_primary(require=false)
        if second & !is_valid_type(first, accept_type) {
            this.Throw("SyntaxError", "Invalid syntax. Expected type.", position=first.position)
        } else if !second & !is_valid_variable_definition(first, accept_var) {
            this.Throw("SyntaxError", $"Invalid syntax. Expected {name}.", position=first.position)
        } else if second & !is_valid_variable_definition(second, accept_var) {
            this.Throw("SyntaxError", $"Invalid syntax. Expected {name}.", position=second.position)
        }
        return {
            type: "TypedVariable",
            given_type: first if second else null,
            variable: second?first,
            position: {
                start: first.position.start,
                end: second.position.end if second else first.position.end
            }
        }


    }
    function parse_assignment() {
        let let_keyword = this.eat("Keyword", "let")
        assignments = []
        while true {
            if assignments.length > 0
                this.eat("Delimiter", ",")
            let variable = this.parse_typed_variable()
            this.eat("Operator", "=")
            let value = this.parse_expression(require=false)
            assignments.add({
                type: "Assignment",
                given_type: variable.given_type,
                variable: variable.variable,
                value,
                position: {
                    start: variable.position.start,
                    end: value.position.end
                }
            })
            if !this.compare("Delimiter", ",") break
        }
        return {
            type: "Assignment",
            assignments,
            position: {
                start: let_keyword.position.start,
                end: assignments.(-1).position.end
            }
        }
    }
}
function test() {
    let code = "let Number | String x = 5"
    let error_handler = ErrorHandler(code, '<main>')
    let lexer = Lexer(false, false, error_handler)
    let tokens = lexer.tokenize(code)
    let parser = Parser(lexer, error_handler)
    let AST = parser.parse()
    stdout.write(AST, '\n')
}
test()