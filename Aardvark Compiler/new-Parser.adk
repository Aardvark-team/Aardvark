from Data include OrderOfOps
include Token, Lexer from Lexer
include ErrorHandler, ADK_Error from Errors


static class Parser as this {
    let String code
    let [...String] code_lines
    let [...Token] tokens
    let Number pos = 0
    let [ErrorHandler, null] error_handler
    let store_errors = false
    let error_stack = []
    $constructor(code, tokens, error_handler=null) {
        this.code = code # The code used by the lexer.
        this.code_lines = this.code.split("\n")
        this.tokens = tokens # The tokens emitted by the lexer.
        this.error_handler = error_handler
    }
    #* Utility *#
    # Gets the token `n` after the current token.
    function peek(n=0)
        return this.tokens.(this.pos + n) if (this.pos + n < this.tokens.length) else null
    
    # Compare the next token with type, value
    function compare(token_type="any", value=null, n=0) {
        if this.is_EOF() return false
        let current_token = this.peek(n)
        if current_token & (token_type == "any" | current_token.type == token_type) & (value == null | value == current_token.value)
            return true
        else return false
    }

    # Advance to the next token.
    function advance(n=1) this.pos += n

    # Helper function for error throwing.
    function Throw(type, message, options={}, note="", kill=true, position=null, here_message="Here") {
        let legacy_errors = false
        if legacy_errors {
            if !(options.underline? | options.marker?) {
                options.underline = {
                    start: position.start.column + 1,
                    end: position.end.column + 1
                }
                options.marker = {
                    start: position.start.column + 1,
                    length: 1 + position.end.column - position.start.column
                }
            }
            if !(options.lineno? | options.line_number? | options.linestart?) {
                options.line_number = position.start.line
            }
            this.error_handler.Throw(type, message, options, note, kill)
        }
        let error = ADK_Error(this.error_handler, {
            error_type: type,
            message,
            location: {
                line: position.start.line - 1, # The error formatter starts line counting at 0.
                column: position.start.column - 1, # The error formatter starts column counting at 0.
            },
            markers: options.markers?[{
                line: position.start.line - 1, # The error formatter starts line counting at 0.
                column: position.start.column - 1, # The error formatter starts column counting at 0.
                length: position.end.column - position.start.column + 1,
                message: here_message
            }],
            ...options
        })
        if store_errors {
            error_stack.add(error)
        } else {
            error.Throw(kill)
        }
        return error
    }


    # Eat all consecutive line breaks
    function eat_line_breaks() while this.compare('LineBreak') this.advance()

    # Is at the end of the file
    function is_EOF() this.pos >= this.tokens.length

    # Throw EOF error
    function throw_EOF_error(expected_token_type="any", expected_token_value=null) {
        let current_line = this.code_lines.(-1)
        # Show the expected token if there is one.
        let suggestion
        if expected_token_value
            suggestion = $'"{expected_token_value}"'
        else 
            suggestion = expected_token_type

        return this.error_handler.ThrowNew({
            error_type: "UnexpectedEndOfFile",
            message: "We didn't expect the file to end so soon!",
            location: {
                line: this.code_lines.length - 1,
                column: current_line.length - 1
            },
            markers: [{
                line: this.code_lines.length - 1,
                column: current_line.length,
                length: expected_token_value.length?1,
                message: $"Expected {suggestion}"
            }]
        }, true)
    }
    # Consume the current token if type and value match, else throw an error
    function eat(token_type="any", value=null) {
        # If it matches, eat and return it.
        if this.compare(token_type, value) {
            let current_token = this.peek()
            this.advance()
            return current_token
        }
        
        # If we're at the end of the file, throw an error.
        if this.is_EOF()
            return this.throw_EOF_error(token_type, value);

        # Otherwise, throw an error because it didn't match.
        return this.Throw(
            "Token",
            $"Token {value ? $'of type {token_type}'} expected, but not found.",
            position = this.peek().position
        )
    }
    function maybe_eat(token_type="any", value=null)
        this.eat() if this.compare(token_type, value) else null
    
    # Actually parse it
    function parse_primary(Boolean require=false, exclude=[],is_deconstruction=false) {
        let current_token = this.peek()
        let Object ast_node

        if !current_token | this.is_EOF()
            return this.throw_EOF_error('expression or statement') if require else null;
        
        # Template Strings
        else if this.compare('Operator', '$') & this.peek(1).compare('String', null, 2) & !exclude.contains('TemplateString') {
            let start = this.eat()
            let string = this.eat()

            let template_string = string.value
            let text = ""
            let index = 0
            let replacements = []
            while index < template_string.length {
                # Handles {{
                if template_string.(index) == "{" & index + 1 < template_string.length & template_string.(index + 1) == "{" {
                    index += 2
                    text += "{"
                }
                # If we hit a {
                else if template_string.(index) == "{" {
                    index++
                    let start_index = index
                    let inner = ""
                    let opener_count = 1
                    
                    # Loop until the string ends or the { is closed
                    while index < template_string.length & opener_count > 0 {
                        if template_string.(index) == "{" opener_count++
                        else if template_string.(index) == "}" opener_count--
                        if opener_count == 0 break
                        inner += template_string.(index)
                        index++
                    }

                    if opener_count > 0 {
                        # Throw error, replacement never closed
                        return this.throw_EOF_error('Delimiter', '}')
                    }

                    if inner == "" {
                        # Throw error, empty replacement
                        return this.throw_EOF_error('')
                    }
                    # Cut off the }
                    inner = inner.slice(0, -1)
                    # Tokenize the code inside {}
                    let inner_tokens = this.lexer.tokenize(inner)
                    # Save current state
                    let saved_tokens = this.tokens
                    let saved_pos = this.pos
                    # Reset State to parse
                    this.tokens = inner_tokens
                    this.pos = 0
                    # Parse
                    inner_ast = this.parse_expression()
                    # Restore State
                    this.tokens = saved_tokens
                    this.pos = saved_pos

                    replacements.add({"from": start_index, "to": index, "value": inner_ast, "string": inner})
                }
                else
                    text += template_string.(index)

                index++
            }
            ast_node = {
                type: "TemplateString",
                position: {start: start.start, end: string.end},
                value: string.value,
                replacements: replacements
            }
        }
        else if current_token.type in ["String", "Number", "Boolean"] {
            this.eat()
            let value
            if current_token.type == "String"
                value = current_token.value
            else if current_token.type == "Boolean"
                value = current_token.value == "true"
            else
                value = Number(current_token.value)
            ast_node = {
                type: current_token.type + 'Literal',
                position: current_token.position,
                value: value,
                quote_style: current_token.variation if current_token.type == "String"
            }
        }
        else if this.compare('Delimiter', '{') & !exclude.contains('Object')
            ast_node = this.parse_object()

        else if this.compare('Delimiter', '[') & !exclude.contains('Array')
            ast_node = this.parse_array(is_deconstruction)
        else if this.compare("Keyword", "set") & this.compare("Delimiter", "{", 1)
            ast_node = this.parse_set()
        # Variables
        else if current_token.type == "Identifier" & !exclude.contains('VariableAccess') {
            this.eat()
            ast_node = {
                type: 'VariableAccess',
                value: current_token.value,
                position: current_token.position
            }
        }
        # Statements surrounded by ()
        else if this.maybe_eat('Delimiter', '(') {
            this.eat_line_breaks()
            ast_node = this.parse_statement(eat_line_breaks=true)
            this.eat_line_breaks()
            this.eat('Delimiter', ')')
        }
        # 
        if this.compare('Keyword')
        match this.peek().value {
            case 'static' {
                let next_token = this.peek(1)
                if next_token.compare('Keyword', 'private')
                    next_token = this.peek(2)
                if next_token.compare('Keyword', 'function')
                    ast_node = this.parse_function_definition()
                else if next_token.compare('Keyword', 'class')
                    ast_node = this.parse_class_definition()
                else
                    return this.Throw('SyntaxError', 'Expected "function" or "class" after "static"', position=next_token.position)
            }
            case 'private' {
                let next_token = this.peek(1)
                if next_token.compare('Keyword', 'static')
                    next_token = this.peek(2)
                if next_token.compare('Keyword', 'function')
                    ast_node = this.parse_function_definition()
                else if next_token.compare('Keyword', 'class')
                    ast_node = this.parse_class_definition()
                else
                    return this.Throw('SyntaxError', 'Expected "function" or "class" after "private"', position=next_token.position)
            }
            case 'function'
                ast_node = this.parse_function_definition()
            case 'class'
                ast_node = this.parse_class_definition()
            case 'if'
                ast_node = this.parse_if_statement()
            case 'while'
                ast_node = this.parse_while_statement()
            case 'for'
                ast_node = this.parse_for_statement()
            case 'match'
                ast_node = this.parse_match_statement()
            case 'await'
                ast_node = this.parse_await_statement()
            case 'let'
                ast_node = this.parse_assignment()
            case 'layout'
                ast_node = this.parse_layout_type()
            case $default {
                return this.Throw('SyntaxError', 'Unexpected keyword "' + this.peek().value + '"', position=this.peek().position)
            }
        }

        while ast_node?false {
            # side-by-side multiply (i.e. 2x)
            if this.compare("Identifier") & this.peek().start.column == ast_node.position.end.column + 1 {
                let token = this.eat()
                ast_node = {
                    type: "Multiply",
                    value: ast_node,
                    variable: token.value,
                    position: {
                        start: ast_node.position.start,
                        end: token.end
                    }
                }
            }
            # Function calls
            if this.compare("Delimiter", '(') & this.peek().start.column == ast_node.position.end.column + 1 & !exclude.contains('FunctionCall') {
                ast_node = this.parse_function_call(ast_node)
                continue
            }
            # Property access
            if this.compare('Delimiter', '.') & this.peek().start.column == ast_node.position.end.column + 1 {
                ast_node = this.parse_property_access(ast_node)
                continue;
            }
            # Re-assignment
            if this.compare("Operator", '=') & !exclude.contains('Reassignment') {
                ast_node = this.parse_reassignment(ast_node)
                continue
            }

            # Tell the user that x[] should be x.()
            if this.compare('Delimiter', '[') & this.peek().start.column == ast_node.position.end.column + 1 {
                let opening_bracket = this.eat()
                let inner_node = this.parse_expression(eat_line_breaks=true)
                let closing_bracket = this.eat('Delimiter', ']')
                let length
                if opening_bracket.position.start.line == closing_bracket.position.start.line
                    length = closing_bracket.position.end.column - opening_bracket.position.end.column + 1
                else # End of the line
                    length = this.code_lines[opening_bracket.position.start.line - 1].length - opening_bracket.position.end.column + 1

                return this.Throw("SyntaxError", "Incorrect property access", {
                    markers: [
                        {
                            line: opening_bracket.position.start.line - 1,
                            column: opening_bracket.position.start.column - 1,
                            length,
                            message: "Use `x.(y)` syntax instead of `x[y]`"
                        }
                    ]
                }, position=opening_bracket.position)
            }
            # inline statements. Don't continue because nothing can come after it.
            if this.compare('Keyword') match this.peek().value {
                case 'if'
                    ast_node = this.parse_if_statement(ast_node)
                case 'while'
                    ast_node = this.parse_while_statement(ast_node)
                case 'for'
                    ast_node = this.parse_for_statement(ast_node)
            }
            # Return if none were found
            return ast_node
        }
        if require {
            return this.Throw('SyntaxError', 'Expected expression or statement', position=this.peek().position)
        }
    }
    function parse_expression(level=keys(OrderOfOps).length-1, require=false, exclude=[], eat_line_breaks=false, is_deconstruction=false) {
        let left = this.parse_primary(false, exclude, is_deconstruction) if level < 0 else this.parse_expression(level - 1, false, exclude, eat_line_breaks, is_deconstruction)
        this.eat_line_breaks() if eat_line_breaks;
        if !exclude.contains("$") exclude += ['$', '='];
        # while the next token is an operator and level in OrderOfOps, and the value of the next token is in the current precedence level and the value of the next token is not in the exclude list.
        while this.compare('Operator') & level in OrderOfOps & this.peek().value in OrderOfOps.(level) & !(this.peek().value in exclude) {
            let operator = this.eat()
            this.eat_line_breaks() if eat_line_breaks;
            let right = this.parse_expression(level - 1, false, exclude, eat_line_breaks, is_deconstruction)
            if !left and !right {
                return this.Throw('SyntaxError', "🤨 That's just an operator with nothing for it to operator on.", position=operator.position)
                # Throw an error because its just an operator all by itself
            }
            left = {
                type: 'Operator',
                left: left,
                right: right,
                operator: operator.value,
                position: {
                    start: left.position.start if left else operator.start,
                    end: right.position.end if right else operator.end
                }
            }
        }
        if !left & require
            left = (this.parse_primary(require, exclude, is_deconstruction)) if level < 0 else (this.parse_expression(level - 1, require, exclude, eat_line_breaks, is_deconstruction));
        return left
    }
    function parse_statement(require=false, is_deconstruction=false) {
        this.eat_line_breaks()
        if this.compare('Keyword') match this.peek().value {
            case 'return'
                return this.parse_return_statement()
            case 'break'
                return this.parse_break_statement()
            case 'continue'
                return this.parse_continue_statement()
            case 'defer'
                return this.parse_defer_statement()
            case 'yield'
                return this.parse_yield_statement()
            case 'include'
                return this.parse_include_statement()
            case 'extending'
                return this.parse_extending_statement()
        }
        return this.parse_expression(require=require, is_deconstruction=false)
    }
    function parse_program() {
        let body = this.parse_scope_body(false)
        return {
            type: "Program",
            body: body.statements,
            position: body.position
        }
    }
    function parse this.parse_program()
    function parse_function_call(ast_node) {

    }
    function parse_property_access(ast_node) {
        let dot = this.eat()
        let property
        if this.compare('Identifier') {
            let token = this.eat()
            property = {
                type: "StringLiteral",
                value: token.value,
                position: token.position
            }
        }
        else if this.compare('Number') {
            let token = this.eat()
            property = {
                type: "NumberLiteral",
                value: Number(token.value),
                position: token.position
            }
        }
        else if this.compare("String") {
            let token = this.eat()
            property = {
                type: "StringLiteral",
                value: token.value,
                position: token.position
            }
        }
        else if this.compare("Delimiter", "(") {
            let token = this.eat()
            property = this.parse_statement(eat_line_breaks=true)
            this.eat('Delimiter', ")")
        } else {
            return this.Throw("SyntaxError", "Expected property name", position=this.peek().position)
        }
        return {
            type: "PropertyAccess",
            property: property,
            value: ast_node,
            position: {
                start: ast_node.position.start,
                end: property.position.end
            }
        }
    }
    function parse_object() {
        let opening_curly_brace = this.eat("Delimiter", "{")
        let pairs = []
        let expansions = []
        # While there is no }
        while (this.peek() & !this.compare("Delimiter", "}") & !(this.compare("Delimiter", ",") & this.peek(1).value == "}")) {
            this.eat_line_breaks()
            if pairs.length > 0 this.eat("Delimiter", ",")
            this.eat_line_breaks()

            # Expansion with ...
            if this.maybe_eat("Operator", "...")
                expansions.add(this.parse_expression(require=true))
            else {
                # TODO: handle $key arbitrary properties
                let key = parse_typed_variable([], ["NumberLiteral", "StringLiteral", "TemplateString"], "object key")
                if type_of(key) == ADK_Error {
                    key.error_number = 1
                    return key
                }
                this.eat_line_breaks()
                let value
                # There is a :, then the value is on the other side
                if this.maybe_eat("Delimiter", ":") {
                    value = this.parse_expression(require=true, eat_line_breaks=true)
                } else # Otherwise, the value is a variable access to the key value
                    value = key.variable
                pairs.add({
                    type: "KeyValuePair",
                    key: key.variable,
                    given_type: key.given_type,
                    value,
                    position: {
                        start: key.position.start,
                        end: value.position.end
                    }
                })
            }
        }
        if this.compare("Delimiter", ",")
            this.eat()
        let closing_curly_brace = this.eat("Delimiter", "}")
        return {
            type: "Object",
            pairs,
            expansions,
            position: {
                start: opening_curly_brace.position.start,
                end: closing_curly_brace.position.end
            }
        }
    }
    function parse_array(is_deconstruction=false) {
        let opening_bracket = this.eat("Delimiter", "[")
        let items = []
        # While there is no ]
        while (this.peek() & !this.compare("Delimiter", "]") & !(this.compare("Delimiter", ",") & this.peek(1).value == "]")) {
            this.eat_line_breaks()
            if items.length > 0 this.eat("Delimiter", ",")
            this.eat_line_breaks()
            if is_deconstruction
                items.add(this.parse_typed_variable())
            else
                items.add(this.parse_expression(require=true))
        }
        if this.compare("Delimiter", ",")
            this.eat()
        let closing_bracket = this.eat("Delimiter", "]")
        return {
            type: "Array",
            items,
            position: {
                start: opening_bracket.position.start,
                end: closing_bracket.position.end
            }
        }
    }
    function parse_layout_type() {
        let layout_keyword = this.eat("Keyword", `layout`)
        this.eat("Delimiter", `(`)
        let type = this.parse_expression(require=true)
        this.eat("Delimiter", `)`)
        this.eat_line_breaks()
        let layout = this.parse_object()
        return {
            type: "LayoutType",
            layout_type: type,
            layout,
            position: {
                start: layout_keyword.position.start,
                end: layout.position.end
            }
        }
    }
    function is_valid_type(expression, accept=[], accept_operators=[]) {
        let valid_operators = Set(accept_operators + ["|", "or", "?"])
        if expression == null | accept.contains(expression.type)
            return true
        else if ["VariableAccess", "PropertyAccess", "LayoutType", "Array", "Object", "KeyValuePair"].contains(expression.type) | (expression.type == "Operator" & valid_operators.contains(expression.operator))
        match expression.type {
            case "VariableAccess"
                return true
            case "PropertyAccess"
                return true
            case "LayoutType"
                return true
            case "Array"
                return !expression.items.map(function (x) is_valid_type(x, [], Array(accept_operators)+["..."])).contains(false)
            case "KeyValuePair"
                return is_valid_type(expression.key)
            case "Object"
                return !expression.pairs.map(is_valid_type).contains(false)
            case "Operator"
                return is_valid_type(expression.left) & is_valid_type(expression.right)
        }
        return false
    }
    function is_valid_variable_definition(expression, accept=[], accept_operators=[]) {
        let valid_operators = accept_operators + ["?"]
        if expression == null | accept.contains(expression.type)
            return true
        else if ["VariableAccess", "PropertyAccess", "Array", "Object", "KeyValuePair", "TypedVariable"].contains(expression.type) | (expression.type == "Operator" & valid_operators.contains(expression.operator))
        match expression.type {
            case "VariableAccess"
                return true
            case "PropertyAccess"
                return true
            case "KeyValuePair"
                return is_valid_variable_definition(expression.value)
            case "Array"
                return !expression.items.map(function (x) is_valid_variable_definition(x, [], ["..."])).contains(false)
            case "Object"
                return !expression.pairs.map(is_valid_variable_definition).contains(false)
            case "Operator"
                return is_valid_type(expression.left) & is_valid_type(expression.right)
            case "TypedVariable"
                return true
        }
        return false
    }
    function parse_typed_variable(accept_var=[], name="variable") {
        #* Valid forms:
        Number x
        x y
        layout(Number) {} x
        String this.y
        x
        y
        this.y
        a.b c.d
        etc... you get the idea
        *#
        # This may be the type or the variable, we don't know until we know IF there is a second expression.
        let first = this.parse_expression(0, true, ["Reassignment"], false, is_deconstruction=true)
        let second = this.parse_expression(0, false, ["Reassignment"], false, is_deconstruction=true)
        if second & !is_valid_type(first) {
            return this.Throw("SyntaxError", "Invalid syntax.", position=first.position, here_message= $"Expected type.")
        } else if !second & !is_valid_variable_definition(first, accept_var) {
            return this.Throw("SyntaxError", $"Invalid syntax.", position=first.position, here_message= $"Expected {name}.")
        } else if second & !is_valid_variable_definition(second, accept_var) {
            return this.Throw("SyntaxError", $"Invalid syntax.", position=second.position, here_message= $"Expected {name}.")
        }
        return {
            type: "TypedVariable",
            given_type: first if second else null,
            variable: second?first,
            position: {
                start: first.position.start,
                end: second.position.end if second else first.position.end
            }
        }


    }
    function parse_assignment() {
        let let_keyword = this.eat("Keyword", "let")
        assignments = []
        while true {
            if assignments.length > 0
                this.eat("Delimiter", ",")
            let is_static = false
            let is_private = false
            # Allow static and private in any order
            if this.maybe_eat("Keyword", "static")
                is_static = true
            if this.maybe_eat("Keyword", "private")
                is_private = true
            if this.maybe_eat("Keyword", "static")
                is_static = true
            let variables = []
            variables.add(this.parse_typed_variable())
            let value
            # TODO: allow chaining: let x = y = 5
            if this.maybe_eat("Operator", "=")
                value = this.parse_expression(require=true, exclude=["Reassignment"])
            assignments.add({
                type: "Assignment",
                variables,
                value: value?,
                is_static: is_static,
                is_private: is_private,
                position: {
                    start: variables.0.position.start,
                    end: value.position.end if value? else variables.(-1).position.end
                }
            })
            if !this.compare("Delimiter", ",") break
        }
        return {
            type: "Assignment",
            assignments,
            position: {
                start: let_keyword.position.start,
                end: assignments.(-1).position.end
            }
        }
    }
    function parse_function_definition(mode="normal", found_static=false) {
        let is_static = found_static
        let is_private = false
        let first_keyword
        if this.compare("Keyword", "static") {
            first_keyword = this.eat()
            is_static = true
        }
        if this.compare("Keyword", "private") {
            let keyword = this.eat()
            if (!first_keyword?)
                first_keyword = keyword
            is_private = true
        }
        if this.compare("Keyword", "static") {
            let keyword = this.eat()
            if (!first_keyword?) 
                first_keyword = keyword
            is_static = true
        }
        let function_keyword
        if mode == "class_scope" & this.compare("Operator", "$")
            function_keyword = this.eat()
        else if mode != "extending"
            function_keyword = this.eat("Keyword", "function")
        if (!first_keyword? & function_keyword?)
            first_keyword = function_keyword

        let name, type, body
        let parameters = []
        let parameter_expansion
        if this.compare("Identifier") {
            let token = this.eat("Identifier")
            name = {
                type: "VariableAccess",
                name: token.value,
                position: token.position
            }
        }

        if (!first_keyword? & name?)
            first_keyword = name

        if this.compare("Delimiter", "(") {
            let opening_parenthesis = this.eat()
            if (!first_keyword?)
                first_keyword = opening_parenthesis
            while !this.compare("Delimiter", ")") {
                if parameters.length > 0 this.eat("Delimiter", ",")
                if this.compare("Operator", "...") {
                    let operator = this.eat()
                    parameter_expansion = this.parse_primary(true)
                    if !["VariableAccess", "PropertyAccess"].contains(parameter_expansion.type) 
                        return this.Throw("SyntaxError", "Invalid syntax.", position=parameter_expansion.position, here_message= $"Expected parameter name.")
                    # An expansion MUST be the last parameter
                    break
                }
                parameters.add(this.parse_typed_variable())
            }
            if this.compare("Delimiter", ",") this.eat()
            let closing_parenthesis = this.eat("Delimiter", ")")
        }
        # Parse return type
        if this.compare("Operator", "->") {
            let operator = this.eat()
            if (!first_keyword?)
                first_keyword = operator
            type = this.parse_primary(require=true)
            if !this.is_valid_type(type) {
                return this.Throw("SyntaxError", "Invalid syntax.", position=type.position, here_message= $"Expected type.")
            }
        }
        if this.compare("Delimiter", "{") {
            body = this.parse_scope_body()
        } else {
            body = this.parse_statement(require=true)
        }
        return {
            type: "FunctionDefinition",
            name: name?,
            parameters,
            parameter_expansion: parameter_expansion?,
            type: type?,
            body: body,
            is_static: is_static,
            is_private: is_private,
            position: {
                start: first_keyword.position.start if first_keyword? else body.position.start,
                end: body.position.end
            }

        }
    }
    function parse_if_statement(ast_node) {
        # ast_node is provided if the body comes before the if keyword. That is, it is an inline if statement.
        # x if y else z
        let if_keyword = this.eat("Keyword", "if")
        let condition = this.parse_expression(require=true)
        let body, else_body
        if ast_node 
            body = ast_node
        else if this.compare("Delimiter", "{")
            body = this.parse_scope_body()
        else
            body = this.parse_statement(require=true)
            
        # Handle else statements
        if this.compare("Keyword", "else") {
            let else_keyword = this.eat("Keyword", "else")
            if this.compare("Delimiter", "{")
                else_body = this.parse_scope_body()
            else
                else_body = this.parse_statement(require=true)
        }
        return {
            type: "IfStatement",
            condition,
            body,
            else_body: else_body?,
            position: {
                start: if_keyword.position.start,
                end: else_body.position.end if else_body? else body.position.end
            }
        }
    }
    function parse_class_definition() {
        let name, body
        let is_static = false
        let is_private = false
        if this.maybe_eat("Keyword", "static")
            is_static = true
        if this.maybe_eat("Keyword", "private")
            is_private = true
        if this.maybe_eat("Keyword", "static")
            is_static = true
        let class_keyword = this.eat("Keyword", "class")
        name = this.maybe_eat("Identifier")
        # TODO
    }
    function parse_extending_statement() {
        let extending_keyword = this.eat("Keyword", "extending")
        let object, extension
        let is_static = false
        if this.compare("Keyword", "static") & this.compare("Keyword", "function", 1) | this.compare("Keyword", "function")
            extension = this.parse_function_definition()
        else if this.compare("Keyword", "static") & this.compare("Keyword", "class", 1) | this.compare("Keyword", "class")
            extension = this.parse_class_definition()
        if (extension?) {
            if (!extension.name?)
                return this.Throw("ExtensionError", "Cannot extend an anonymous class.", position=extension.position)
            return {
                type: "ExtendingStatement",
                object: extension.name,
                extension,
                position: {
                    start: extending_keyword.position.start,
                    end: extension.position.end
                }
            }
        }
        if this.maybe_eat("Keyword", "static")
            is_static = true
        if this.compare("Identifier") {
            # Needs to handle x, x.y, x.(y)
            let identifier = this.eat()
            object = {
                type: "VariableAccess",
                value: identifier.value,
                position: identifier.position
            }
            if this.compare('Delimiter', '.') & this.peek().start.column == ast_node.position.end.column + 1 {
                object = this.parse_property_access(object)
            }
        } else if this.compare("Operator") {
            let operator = this.eat()
            object = {
                type: "OperatorValue",
                value: operator.value,
                position: operator.position
            }
        }
        if this.compare("Operator", "->") {
            let operator = this.eat()
            let type = this.parse_primary(require=true)
            if !this.is_valid_type(type) {
                return this.Throw("SyntaxError", "Invalid syntax.", position=type.position, here_message= $"Expected type.")
            }
            let body
            if this.compare("Delimiter", "{") {
                this.store_errors = true
                body = this.parse_object()
                if type_of(body) == ADK_Error & body.error_number == 1 {
                    extension = this.parse_scope_body()
                }
                this.store_errors = false
            } else {
                body = this.parse_statement(require=true)
            }
            extension = {
                type: "FunctionDefinition",
                name: object,
                type: type,
                parameters: [],
                parameter_expansion: null,
                is_static: is_static,
                is_private: null,
                body: body,
                position: {
                    start: object.position.start,
                    end: body.position.end
                }
            }
        } else if this.compare("Delimiter", "(") {
            extension = this.parse_function_definition("extending", is_static)
        } else if this.compare("Delimiter", "[") {
            extension = this.parse_array()
        } else if this.compare("Delimiter", "{") {
            this.store_errors = true
            extension = this.parse_object()
            if type_of(extension) == ADK_Error & extension.error_number == 1 {
                extension = this.parse_scope_body()
            }
            this.store_errors = false
        } else {
            extension = this.parse_statement(require=true)
        }


        return {
            type: "ExtendingStatement",
            object,
            extension,
            position: {
                start: extending_keyword.position.start,
                end: extension.position.end
            }
        }
    }
    function parse_function_call() {
        let opening_parenthesis = this.eat("Delimiter", "(")
        let parameters = []
        let keyword_arguments = []
        # let 
        # TODO
    }
    function parse_reassignment(ast_node) {
        if !this.is_valid_variable_definition(ast_node) {
            return this.Throw("SyntaxError", $"Invalid syntax.", position=ast_node.position, here_message= $"Expected identifier (variable or property).")
        }
        let objects = [ast_node]
        let value
        # Reassignment chaining, x = y = z
        while true {
            this.eat("Operator", "=")
            if (value?) {
                if !this.is_valid_variable_definition(ast_node) {
                    return this.Throw("SyntaxError", $"Invalid syntax.", position=ast_node.position, here_message= $"Expected identifier (variable or property).")
                }
                objects.add(value)
            }
            value = this.parse_expression(require=true, exclude=["Reassignment"])
            if !this.compare("Operator", "=") break
        }

        return {
            type: "Reassignment",
            objects,
            value,
            position: {
                start: ast_node.position.start,
                end: value.position.end
            }
        }
    }
    function parse_scope_body(enclosing_curly_braces=true) {
        let beginning_token = this.peek()
        let opening_curly_brace, closing_curly_brace
        if enclosing_curly_braces 
            opening_curly_brace = this.eat("Delimiter", "{")
        let statements = []
        while (!enclosing_curly_braces | !this.compare("Delimiter", "}")) & !this.is_EOF() {
            if statements.length > 0 & this.peek(-1).type != 'LineBreak' this.eat('LineBreak')
            this.eat_line_breaks()
            if this.is_EOF() | (enclosing_curly_braces & this.compare("Delimiter", "}")) break;
            statements.add(this.parse_statement(true))
        }

        if enclosing_curly_braces 
            closing_curly_brace = this.eat("Delimiter", "}")

        let start_position, end_position
        if !enclosing_curly_braces & this.is_EOF() & statements.length == 0 {
            # There was nothing here at all
            start_position = null 
            # It has no start and no end, because it is nothing.
            end_position = null
        } else if !enclosing_curly_braces & this.is_EOF() & statements.length > 0 {
            # There was something, but it ended with an EOF
            start_position = statements.0.position.start
            end_position = this.peek(-1).position.end
        } else if !enclosing_curly_braces & statements.length == 0 {
            # There wasn't anything here, but there's more to the file.
            start_position = null 
            # It has no start and no end, because it is nothing.
            end_position = null
        } else if !enclosing_curly_braces & statements.length > 0 {
            # There was something here, but no curly braces to enclose it. There was no EOF.
            start_position = beginning_token ? statements.0.position.start
            end_position = this.peek(-1).position.end
        } else if enclosing_curly_braces {
            # It was enclosed, so the start is the opening curly brace and the end is the closing
            start_position = opening_curly_brace.position.start
            end_position = closing_curly_brace.position.end
        } 
        return {
            type: "ScopeBody",
            statements,
            position: {
                start: start_position,
                end: end_position
            }
        }
    }
}

# Comment out the ones we are not working on to save test time.
let parser_tests = {
    property_access: "x.y.z",
    function_definition: "private static function x(Number x, y, {Number a, b, c:d}, [String a, b, c], this.y, ...args) -> Number {}",
    if_else_statement: "if condition {\n\n x\n\n\n } else if condition { y } else { z }",
    object_type: "let {Number x, String y} x",
    optional_type: "let String? x",
    optional_type_no_annotations: "let x? = y",
    typed_deconstruction: "let [String a, b, Number c] = x",
    object: "{x: 5, y: 6, Number z: 7, d, ...y}",
    array_extending: "extending x [5, 6, 7, 8, 9, 10]",
    function_extending: "extending x(y, z) -> Number {}",
    function_extending_no_parameters: "extending x {}",
    function_extending_no_parameters_with_return_type_annotation: "extending x -> Number {}",
    object_extending: "extending x {y: 5, z: 6}",
    operator_extending: "extending +(Number x, String y) -> String {}",
    reassignment: "x = y = z = 5",
    template_string: "$'Hello, {name}!'",

}
let error_tests = {
    assign_value: "let 5 = x",
    else_without_if: "else { x }",
    anonymous_function_extension: "extending function {}",
}
function test(String code) {
    let error_handler = ErrorHandler(code, '<main>')
    let lexer = Lexer(false, false, error_handler)
    let tokens = lexer.tokenize(code)
    stdout.write(tokens, '\n')
    let parser = Parser(code, tokens, error_handler)
    let AST = parser.parse()
    if parser.error_stack.length > 0
        return false
    return AST
}
# test("$'hello,,,{ghh")
# test(error_tests.assign_value)
for test_name:code in parser_tests {
    let passed = test(code)
    if passed
        stdout.write("PASSED: ", test_name, "\n")
}
# for test_name:code in error_tests {
#     test(code)
# }