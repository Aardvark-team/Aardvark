include TokenTypes, Operators, Keywords, Quotes, Whitespaces, Booleans, Delimiters, NotIncluded, BaseNumsOrder from Data
include Errors

class Token as this {
    let String type
    let Number length
    let Object start
    let Object end
    let String value
    let String variation
    let Object position
    let Array insertions
    $constructor(type, 
            start, 
            end,
            value = null,
            variation = null, 
            insertions=null) 
    {
    this.type = type
    this.length = end.index - start.index + 1
    this.start = start
    this.end = end
    this.value = value
    this.variation = variation
    this.insertions = insertions
    this.position = {
        start: start,
        end: end
    }
  }
  $string() {
    return $"Token({this.type}, \"{this.value}\", from {this.start.line}:{this.start.column} to {this.end.line}:{this.end.column})"
  }
  function compare(type, value, startcol) {
      if (!type | this.type == type) & (!value | this.value == value) & (!startcol | this.start.column == startcol)
          return true;
      return false;
  }
}


class Lexer as this {
  let Boolean useIndents
  let Boolean tokenizeComments
  let String data
  let Number index
  let Number line
  let Number column
  let [...Token] output
  let Boolean empty
  let Boolean AtEnd
  let String current_character
  let error_stack = []
  let position

  $constructor(useIndents = false, tokenizeComments = false) {
    this.useIndents = useIndents
    this.tokenizeComments = tokenizeComments
    this.data = ""
    this.position = {
        index: 0,
        line: 0,
        column: 0
    }
    #TODO: merge index, line, and column into a position attribute
    this.output = []
    this.empty = true
    this.AtEnd = false
    this.error_stack = []
    this.current_character = ""
  }
  function Throw(options) {
    this.error_stack.add(options)
  }

  function isWhitespace(char)
    (char ? this.current_character) in Whitespaces

  function isNewline(char)
    (char ? this.current_character) in '\n;'

  function isQuote(char)
    (char ? this.current_character) in Quotes

  function isDelimiter(char)
    (char ? this.current_character) in Delimiters 

  function isNumber(char)
    (char ? this.current_character) in '0123456789'

  function addToken(type, start, end, value, variety, insertions)
    this.output.add(Token(type, start, end, value, variety, insertions))

  function otherwise(char) {
    char = char ? this.current_character
    return !(this.isWhitespace(char) | this.isDelimiter(char) | this.isNewline(char) | char == '#' | char in Operators)
  }
  function detect(text) {
    if this.current_character == text.0 {
        for i in sequence(1, 1, text.length - 1) {
            if this.peek(i) != text.(i) | i > this.data.length return false;
        }
    } else return false;
    return true
  }
  function newline() {
    this.empty = true
    this.position.line += 1
    this.position.column = 1
  }
  function advance(amt = 1) {
    this.position.index += amt
    this.position.column += amt
    if this.position.index < this.data.length
      this.current_character = this.data.(this.position.index)
    else 
      this.AtEnd = true
  }
  function peek(amt = 1) {
    if this.position.index + amt < this.data.length 
      return this.data.(this.position.index + amt)
    else return null;
  }
  function pos
    {index: this.position.index, line: this.position.line, column: this.position.column}

  function tokenize(data="") {
    #*
      Takes code and converts it to tokens.
    *#
    this.data = data
    this.position.index = 0
    this.position.line = 1
    this.position.column = 1
    this.output = []
    this.empty = true
    this.AtEnd = false
    this.current_character = this.data.(this.position.index)
    while this.position.index < this.data.length {
        # Operators
        let Operators_array_sorted = Array(Operators)
        Operators_array_sorted.sort(function (a, b) b.length - a.length)
        for operator in Operators_array_sorted
          if this.detect(operator) {
            let start = this.pos()
            this.advance(operator.length - 1)
            this.addToken("Operator", start, this.pos(), operator)
            this.advance()
            break
          }

      # Newlines (\n or ;)
      if this.isNewline() {
        let character = this.current_character
        this.addToken('LineBreak', this.pos(), this.pos(), character, character)
        this.advance()
        if character = '\n' this.newline(); # Only increment the line if its a \n
        else this.empty = true
        continue
      }

      # Indents
      else if this.isWhitespace() & this.empty & this.useIndents {
        value = ''
        start = this.position.index
        startcolumn = this.position.column
        while this.isWhitespace() & !this.AtEnd {
          value = value + this.current_character
          this.advance()
        }
        if !this.isNewline() {
          this.advance(-1)
          this.addToken('Indent', start, this.pos(), value)
        }
        else this.advance(-1);
      }

      #Numbers
      else if this.isNumber() {
        let start = this.pos()
        let base = 10
        let underscore_position
        let value = ''
        let dot_position
        let characters = BaseNumsOrder.slice(0, base)
        while (characters.contains(this.current_character) | '._'.contains(this.current_character)) & !this.AtEnd {
          if dot_position? & this.current_character == '.' & this.peek() in characters
            this.Throw({
              message: "A Number may not have two decimal points!",
              error_type: "SyntaxError",
              location: {
                line: this.position.line - 1,
                column: this.position.column - 1
              },
              markers: [{
                line: dot_position.line - 1,
                column: dot_position.column - 1,
                length: 1,
                message: "First decimal point."
              }, {
                line: this.position.line - 1,
                column: this.position.column - 1,
                length: 1,
                message: "Second decimal point."
              }]
            })
          else if underscore_position? & this.current_character == '_'
            this.Throw({
              message: "Number base already defined!\nHint: The value left of the underscore (_) represents the base of the Number. (e.g. 16_1ab would be hex and 2_0101 would be binary)",
              error_type: "SyntaxError",
              location: {
                line: this.position.line - 1,
                column: this.position.column - 1
              },
              markers: [{
                line: start.line - 1,
                column: start.column - 1,
                length: start.column - underscore_position.column + 1,
                message: "Number base."
              }, {
                line: this.position.line - 1,
                column: this.position.column - 1,
                length: 1,
                message: "Second underscore."
              }]
            })
          else if this.current_character == '.' 
            dot_position = this.pos();
          else if this.current_character == '_' {
            underscore_position = this.pos();
            base = Number(value)
            characters = BaseNumsOrder.slice(0, base)
            value = ''
            this.advance()
            continue
          }
          value += this.current_character
          this.advance()
        }
        if value.(-1) == "." {
          value = value.slice(0, -1)
          this.advance(-1)
        }
        this.advance(-1)
        this.addToken('Number', start, this.pos(), value, base)
      }

      # Multiline comments
      else if this.detect('#*') {
        value = ''
        start = this.pos()
        while !this.detect('*#') & !this.AtEnd {
            value = value + this.current_character
            if this.current_character == '\n' this.newline()
            this.advance()
        }
        this.advance('*#'.length - 1) # To skip the *#
        if (this.tokenizeComments) this.addToken('Comment', start, this.pos(), value)
      }

      # Single line comments
      else if this.current_character == '#' {
        value = ''
        start = this.pos()
        while this.current_character != '\n' & !this.AtEnd {
          value = value + this.current_character
          this.advance()
        }
        if (this.tokenizeComments) this.addToken('Comment', start, this.pos(), value)
      }

      # Strings
      else if this.isQuote() | (this.current_character == '$' & this.isQuote(this.peek(1))) {
        let is_template_string = false
        let insertions = []
        if this.current_character == '$' {
          this.advance()
          is_template_string = true
        }
        let variation = this.current_character
        let value = ''
        let start = this.pos()
        let backslash = false
        while !this.AtEnd {
          this.advance()
          if this.AtEnd 
            this.Throw({
              message: "String was not terminated",
              error_type: "UnexpectedEndOfFile",
              location: {
                line: this.pos().line - 1,
                column: this.pos().column - 1
              },
              markers: [{
                line: this.pos().line - 1,
                column: start.column - 1 if value.split('\n').length == 1 else 0,
                length: value.split('\n').(-1).length + 1,
                message: "This is the string."
              }, {
                line: this.pos().line - 1,
                column: this.pos().column - 1,
                length: 1,
                message: "Put your quote here."
              }]
            })
          # Handle escape sequences
          if backslash {
            if this.current_character == '\\' value = value + '\\'
            else if this.current_character == 'n' value = value + '\n'
            else value = value + this.current_character
            backslash = false
          }
          # Handle template strings
          else if is_template_string and this.current_character == '{' {
            let expression_text = ''
            let expression_start = this.pos()
            while !this.AtEnd and this.current_character != '}' {
              expression_text += this.current_character
              this.advance()
            }
            if this.AtEnd {
              this.Throw({
                error_type: "UnexpectedEndOfFile",
                message: "Template string was not terminated",
                location: {
                  line: this.pos().line - 1,
                  column: this.pos().column - 1
                },
                markers: [{
                  line: this.pos().line - 1,
                  column: start.column - 1 if value.split('\n').length == 1 else 0,
                  length: value.split('\n').(-1).length
                }]
              })
            }
            expression_text = expression_text.slice(1, 0)
            let new_lexer = Lexer(expression_text, this.tokenizeComments)
            let expression_tokens = new_lexer.tokenize(expression_text)
            for token in expression_tokens {
              token.position.start.index += expression_start.index
              token.position.start.line += expression_start.line - 1
              token.position.start.column += expression_start.column - 1
              token.position.end.index += expression_start.index
              token.position.end.line += expression_start.line - 1
              token.position.end.column += expression_start.column - 1
            }
            # stdout.log(expression_tokens)
            insertions.add({
              position: value.length - 1,
              tokens: expression_tokens,
              expression_text
            })
          }
          else {
            if (this.current_character == '\\') backslash = true
            else if this.current_character == variation break
            else value = value + this.current_character
          }
        }
        this.addToken('String', start, this.pos(), value, variation, insertions)
      }

      # Delimiters
      else if this.isDelimiter() 
        this.addToken('Delimiter', this.pos(), this.pos(), this.current_character)

      # Identifiers, Keywords, and Operators
      else if this.otherwise() {
        value = ''
        start = this.pos()
        while (this.otherwise() or this.isNumber()) & !this.AtEnd {
          value += this.current_character
          this.advance()
        }
        this.advance(-1)
        type = 'Identifier'
        (type = 'Operator') if value in Operators else
        (type = 'Keyword') if value in Keywords else
        (type = 'Boolean') if value in Booleans
        this.addToken(type, start, this.pos(), value)
      }

      # Advance
      (break) if this.AtEnd
      this.advance()
    }
    return this.output
  }
}